package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"log"
	"math/rand"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/kobbi/vbciapi/graph/model"
	"github.com/kobbi/vbciapi/graph/schemas"
	"github.com/kobbi/vbciapi/jwt/helpers"
	"github.com/kobbi/vbciapi/jwt/middleware"
	"github.com/lib/pq"
	"gorm.io/gorm"
)

// ID is the resolver for the ID field.
func (r *callCenterResolver) ID(ctx context.Context, obj *model.CallCenter) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// ID is the resolver for the id field.
func (r *churchResolver) ID(ctx context.Context, obj *model.Church) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// ID is the resolver for the id field.
func (r *memberResolver) ID(ctx context.Context, obj *model.Member) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// Types is the resolver for the types field.
func (r *memberResolver) Types(ctx context.Context, obj *model.Member) ([]string, error) {
	// return obj.Types, nil

	if obj.Types == nil {
		return nil, nil // Return null for the field when it's null in the database
	}

	// Convert the pq.StringArray to a slice of pointers to strings
	types := make([]*string, len(obj.Types))
	for i, t := range obj.Types {
		types[i] = &t
	}

	return obj.Types, nil
}

// ID is the resolver for the id field.
func (r *migrationRequestResolver) ID(ctx context.Context, obj *model.MigrationRequest) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// RequestSubChurchMigration is the resolver for the requestSubChurchMigration field.
func (r *mutationResolver) RequestSubChurchMigration(ctx context.Context, input model.SubChurchMigrationInput) (*model.MigrationRequest, error) {
	// You need to implement the logic to create a new migration request based on the input.

	// Check if the member exists based on input.memberId
	member, err := r.Query().Getmember(ctx, input.MemberID)
	if err != nil {
		return nil, fmt.Errorf("Member not found")
	}

	// Check if the destination sub-church exists based on input.destinationChurchId
	destinationChurch, err := r.Query().GetsubChurchByID(ctx, input.DestinationChurchID)
	if err != nil {
		return nil, fmt.Errorf(" Destination sub Church not found")
	}
	memberID := member.ID.String()
	destinationChurchID := destinationChurch.ID.String()

	PENDING := model.MigrationStatusPending

	// Create a new MigrationRequest record
	migrationRequest := &model.MigrationRequest{
		LocationFrom:        &member.SubChurch.Name,
		LocationEnd:         &destinationChurch.Name,
		MemberID:            &memberID,
		MemberName:          &member.Name,
		DestinationChurchID: destinationChurchID,
		Status:              &PENDING,
	}

	// Save the migration request to the database

	if err := r.DB.Create(migrationRequest).Error; err != nil {
		return nil, fmt.Errorf("failed to save to the database: %w", err)
	}

	// Return the created migration request
	return migrationRequest, nil
}

// ApproveSubChurchMigration is the resolver for the approveSubChurchMigration field.
func (r *mutationResolver) ApproveSubChurchMigration(ctx context.Context, requestID string) (*model.MigrationRequest, error) {
	// Check if the migration request exists based on requestID
	migrationRequest, err := r.Query().GetMigration(ctx, requestID)
	if err != nil {
		return nil, fmt.Errorf(" Migration request not found")
	}
	PENDING := model.MigrationStatusPending
	Approved := model.MigrationStatusApproved
	APPROVED := "APPROVED"
	REJECTED := "REJECTED"

	// Rejected := model.MigrationStatusRejected
	_ = model.MigrationStatusCompleted
	// fmt.Printf("migrationRequest value: %v\n",migrationRequest.Status)

	// Check if the current status is pending and update it to approved
	if PENDING != "PENDING" {
		return nil, fmt.Errorf(" Migration request is not in a pending state and cannot be approved")
	}
	if REJECTED == string(*migrationRequest.Status) {
		return nil, fmt.Errorf(" Migration request is already Rejected")
	}
	if APPROVED == string(*migrationRequest.Status) {
		return nil, fmt.Errorf(" Migration request is already Approved")
	}
	// Start a database transaction
	tx := r.DB.Begin()
	if tx.Error != nil {
		return nil, fmt.Errorf(" Failed to start a database transaction: %w", tx.Error)
	}
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback() // Rollback the transaction on any panics
		}
	}()

	// Create a WaitGroup to wait for both goroutines
	var wg sync.WaitGroup

	// Update the status to approved
	migrationRequest.Status = &Approved
	if err := tx.Save(migrationRequest).Error; err != nil {
		tx.Rollback()
		return nil, fmt.Errorf(" Failed to update migration request status: %w", err)
	}

	// Goroutine to update the member's data
	wg.Add(1)
	go func() {
		defer wg.Done()

		// Update the member's data
		Member := &model.Member{}
		// Retrieve the Member from the database based on the provided ID
		if err := r.DB.Where("id = ?", migrationRequest.MemberID).First(Member).Error; err != nil {
			tx.Rollback()
			return
		}

		// Modify the member's data as needed
		Member.SubChurchID = nil
		Member.LeaderID = nil
		Member.Types = nil
		Member.Password = nil
		Member.Token = nil
		Member.ReferenceIDCount = nil
		Member.SubChurchID = &migrationRequest.DestinationChurchID

		// Save the updated Member data
		if err := tx.Save(Member).Error; err != nil {
			tx.Rollback()
		}
	}()

	// Goroutine to delete all the registrations associated with the member
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := tx.Where("member_id = ?", migrationRequest.MemberID).Delete(&model.Registration{}).Error; err != nil {
			tx.Rollback()
		}
	}()

	// Wait for both goroutines to finish
	wg.Wait()

	// Commit the transaction if all updates and deletions are successful
	if err := tx.Commit().Error; err != nil {
		return nil, fmt.Errorf(" Failed to commit the transaction: %w", err)
	}

	// Return the updated migration request
	return migrationRequest, nil
}

// RejectSubChurchMigration is the resolver for the rejectSubChurchMigration field.
func (r *mutationResolver) RejectSubChurchMigration(ctx context.Context, requestID string) (*model.MigrationRequest, error) {
	// Check if the migration request exists based on requestID
	migrationRequest, err := schemas.GetMigrationRequestByID(r.DB, requestID)
	if err != nil {
		return nil, fmt.Errorf(" Migration request not found")
	}
	// Approved := model.MigrationStatusApproved
	Rejected := model.MigrationStatusRejected
	APPROVED := "APPROVED"
	REJECTED := "REJECTED"

	// // Check if the current status is pending and update it to rejected
	if APPROVED == string(*migrationRequest.Status) {
		return nil, fmt.Errorf(" The migration request has already been approved and is not in a pending state, so it cannot be rejected")
	}

	if REJECTED == string(*migrationRequest.Status) {
		return nil, fmt.Errorf(" The migration request has already been marked as rejected and cannot be rejected again")
	}

	// // Update the status to rejected
	migrationRequest.Status = &Rejected

	// Start a database transaction
	tx := r.DB.Begin()
	if tx.Error != nil {
		return nil, fmt.Errorf(" Failed to start a database transaction: %w", tx.Error)
	}
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback() // Rollback the transaction on any panics
		}
	}()

	// Save the updated migration request to the database within the transaction
	if err := tx.Save(migrationRequest).Error; err != nil {
		tx.Rollback() // Rollback the transaction on error
		return nil, fmt.Errorf(" Failed to update the migration request: %w", err)
	}

	// If the status is rejected, delete the migration request from the database
	if migrationRequest.Status == &Rejected {
		// Sleep for 1 minute before deleting
		// time.Sleep(1 * time.Minute)
		if err := tx.Delete(migrationRequest).Error; err != nil {
			tx.Rollback() // Rollback the transaction on error
			return nil, fmt.Errorf(" Failed to delete the migration request: %w", err)
		}
	}

	// Commit the transaction if all updates are successful
	if err := tx.Commit().Error; err != nil {
		return nil, fmt.Errorf(" Failed to commit the transaction: %w", err)
	}

	// Return the updated (or deleted) migration request
	return migrationRequest, nil
}

// CreateMember is the resolver for the createMember field.
func (r *mutationResolver) CreateMember(ctx context.Context, input *model.CreateMemberInput) (*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}

	// Check if email already exists
	members := &model.Member{}
	// Call the checking Duplicate Records function if already in db
	if err := schemas.CheckDuplicateRecords(r.DB, members, input.Name, input.Email, *input.PhoneNumber); err != nil {
		return nil, err
	}

	// Find the leader for the new member's day using FindLeaderWithSameDay
	leader, err := schemas.FindLeaderWithSameDay(ctx, r.DB, input.Day, input.ChurchID)
	if err != nil {
		return nil, fmt.Errorf("failed to create member : ")
	}
	// Convert leader .ID to a string before assigning it to LeaderID
	leaderID := leader.ID.String()
	PhoneNumber := schemas.CleanPhoneNumber(*input.PhoneNumber)

	member := &model.Member{
		Name:        input.Name,
		Email:       input.Email,
		PhoneNumber: &PhoneNumber,
		Day:         input.Day,
		Location:    input.Location,
		SubChurchID: &input.ChurchID,
		LeaderID:    &leaderID, // Assign the LeaderID to the selected leader's ID
	}

	// Save the member to the database using your preferred ORM-
	if err := r.DB.Create(member).Error; err != nil {
		return nil, fmt.Errorf("failed to save member to the database: %w", schemas.ErrDatabase)
	}
	// Call UpdateReferenceIDCounts to ensure the counts are up-to-date.
	if err := schemas.UpdateReferenceIDCounts(r.DB, input.ChurchID); err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}
	return member, nil
}

// CreateMemberbySubchurch is the resolver for the createMemberbySubchurch field.
func (r *mutationResolver) CreateMemberbySubchurch(ctx context.Context, input *model.CreateMemberInput) (*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	subChurchID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("leaderID not found in request context")
	}
	// Check if email already exists
	members := &model.Member{}
	// Call the checking Duplicate Records function if already in db
	if err := schemas.CheckDuplicateRecords(r.DB, members, input.Name, input.Email, *input.PhoneNumber); err != nil {
		return nil, err
	}
	var leaders []model.Member

	// if err := r.DB.Where("types IN (?) AND sub_church_id = ?", pq.Array([]string{"Leader", "SubLeader"}), churchID).Find(&leaders).Error; err != nil {
	// 	fmt.Println("Database error:", err)
	// 	return nil, err
	// }
	if err := r.DB.Where("sub_church_id = ? AND types && ?", subChurchID, pq.Array([]string{"Leader", "SubLeader"})).Find(&leaders).Error; err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}

	var lop *model.Member
	if len(leaders) == 1 {
		// // Get the leader for the given churchID
		leader, err := schemas.GetLeaderByChurchID(r.DB, &subChurchID)
		if err != nil {
			return nil, err
		}
		lop = leader

	} else if len(leaders) > 1 {

		// // Get the leader for the given churchID
		leader, err := schemas.FindLeaderWithSameDay(ctx, r.DB, input.Day, subChurchID)
		if err != nil {
			return nil, err
		}
		lop = leader
	}

	leaderID := lop.ID.String()
	// Find the leader for the new member's day using FindLeaderWithSameDay

	// Convert leader .ID to a string before assigning it to LeaderID
	// leaderID := leader.ID.String()
	PhoneNumber := schemas.CleanPhoneNumber(*input.PhoneNumber)

	member := &model.Member{
		Name:        input.Name,
		Email:       input.Email,
		PhoneNumber: &PhoneNumber,
		Day:         input.Day,
		Location:    input.Location,
		SubChurchID: &subChurchID,
		LeaderID:    &leaderID, // Assign the LeaderID to the selected leader's ID
	}

	// Save the member to the database using your preferred ORM-
	if err := r.DB.Create(member).Error; err != nil {
		return nil, fmt.Errorf("failed to save member to the database: %w", schemas.ErrDatabase)
	}
	// Call UpdateReferenceIDCounts to ensure the counts are up-to-date.
	if err := schemas.UpdateReferenceIDCounts(r.DB, input.ChurchID); err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}
	return member, nil
}

// ImportMemberData is the resolver for the importMemberData field.
func (r *mutationResolver) ImportMemberData(ctx context.Context, file graphql.Upload, churchID *string) ([]*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo4AdminOnly(ctx)
	if err != nil {
		return nil, err
	}

	// Create a buffer to read the data from the file.
	buffer := new(bytes.Buffer)

	// Read the data from the file into the buffer.
	_, err = io.Copy(buffer, file.File)
	if err != nil {
		return nil, err
	}

	// Convert the data in the buffer to a string.
	fileDataString := buffer.String()

	// Convert the Excel data to a CSV file.
	csvFilePath, err := schemas.ConvertExcelToCSV(fileDataString)
	if err != nil {
		return nil, err
	}

	// Log the path of the created CSV file.
	fmt.Printf("Created CSV file: %s\n", csvFilePath)

	// Convert the Excel data to a CSV file.
	data, err := schemas.ProcessCSVFile(ctx, csvFilePath, *churchID, r.DB)
	if err != nil {
		return nil, err
	}
	// Remove the temporary directory after using the file
	schemas.RemoveTempDir(filepath.Dir(csvFilePath))

	return data, nil
}

// DataMembers is the resolver for the dataMembers field.
func (r *mutationResolver) DataMembers(ctx context.Context) (*string, error) {
	// member := &model.Member{}
	targetDate := "11/20/2023"

	// Delete members created on the target date
	if err := r.DB.Where("DATE(created_at) = ?", targetDate).Delete(&model.Member{}).Error; err != nil {
		return nil, fmt.Errorf("failed to delete members: %w", err)
	}

	// Return the count of remaining members as a success message
	successMessage := fmt.Sprintf("Deleted members created on %s", targetDate)
	return &successMessage, nil
}

// CleanUpPhoneNumbers is the resolver for the cleanUpPhoneNumbers field.
func (r *mutationResolver) CleanUpPhoneNumbers(ctx context.Context) ([]*string, error) {
	// Retrieve all phone numbers from the database
	var phoneNumbers []string
	if err := r.DB.Model(&model.Member{}).Pluck("phone_number", &phoneNumbers).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve phone numbers: %w", err)
	}

	// Clean and update each phone number
	cleanedPhoneNumbers := make([]*string, 0, len(phoneNumbers))
	for _, phoneNumber := range phoneNumbers {
		cleanedPhoneNumber := schemas.CleanPhoneNumber(phoneNumber)

		// Update the cleaned phone number in the database
		if err := r.DB.Model(&model.Member{}).Where("phone_number = ?", phoneNumber).Update("phone_number", cleanedPhoneNumber).Error; err != nil {
			return nil, fmt.Errorf("failed to update phone number: %w", err)
		}

		// Append the cleaned phone number to the result list
		cleanedPhoneNumbers = append(cleanedPhoneNumbers, &cleanedPhoneNumber)
	}

	return cleanedPhoneNumbers, nil
}

// CreateMemberBysubLeader is the resolver for the createMemberBysubLeader field.
func (r *mutationResolver) CreateMemberBysubLeader(ctx context.Context, input *model.CreateMemberInputBySub) (*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("leaderID not found in request context")
	}
	// Query the leader
	leader := &model.Member{}
	if err := r.DB.Where("id = ?", leaderID).First(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to find leader: %w", err)
	}
	// Check if  email already exists
	members := &model.Member{}
	// Call the checking Duplicate Records function if already in db
	if err := schemas.CheckDuplicateRecords(r.DB, members, input.Name, input.Email, *input.PhoneNumber); err != nil {
		return nil, err
	}
	PhoneNumber := schemas.CleanPhoneNumber(*input.PhoneNumber)

	member := &model.Member{
		Name:        input.Name,
		Email:       input.Email,
		PhoneNumber: &PhoneNumber,
		Day:         input.Day,
		Location:    input.Location,
		SubChurchID: &leader.SubChurch.ChurchID,
	}
	// Save the member to the database using your preferred ORM
	if err := r.DB.Create(member).Error; err != nil {
		return nil, fmt.Errorf("failed to save member to the database: %w", schemas.ErrDatabase)
	}
	return member, nil
}

// UpdateMember is the resolver for the updateMember field.
func (r *mutationResolver) UpdateMember(ctx context.Context, input model.UpdateMemberInput, memberID string) (*model.Member, error) {
	// Extract LeaderID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}

	Member := &model.Member{}
	// Retrieve the Member from the database based on the provided ID
	if err := r.DB.Where("id = ?", memberID).First(Member).Error; err != nil {
		return nil, err
	}

	// Check if the provided email is already used by another member
	if input.Email != nil {
		if err := r.DB.Where("email = ?", *input.Email).Not("id = ?", memberID).First(&model.Member{}).Error; err == nil {
			return nil, fmt.Errorf("email already exists")
		}
	}

	// Clean and update the phone number if provided
	if input.PhoneNumber != nil {
		PhoneNumber := schemas.CleanPhoneNumber(*input.PhoneNumber)
		Member.PhoneNumber = &PhoneNumber
	}

	// Update the Member's fields with the input values if they are provided
	if input.Name != nil {
		Member.Name = *input.Name
	}
	if input.Email != nil {
		Member.Email = *input.Email
	}
	if input.Day != nil {
		Member.Day = *input.Day
	}
	if input.Location != nil {
		Member.Location = input.Location
	}

	// Save the Member to the database
	if err := r.DB.Save(Member).Error; err != nil {
		return nil, err
	}

	// Return the updated Member
	return Member, nil
}

// UpdateLeader is the resolver for the updateLeader field.
func (r *mutationResolver) UpdateLeader(ctx context.Context, input model.UpdateLeaderProfileInput, memberID string) (*model.Member, error) {
	leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("leaderID not found in request context")
	}

	// Check if the authenticated user is the same as the member being updated.
	if leaderID != memberID {
		return nil, fmt.Errorf("unauthorized: you can only update your own profile")
	}
	// Fetch the leader from the database using memberID.
	leader := &model.Member{}
	if err := r.DB.First(leader, "id = ?", leaderID).Error; err != nil {
		return nil, fmt.Errorf("leader not found: %w", err)
	}
	if err := helpers.VerifyPassword(*leader.Password, *input.Oldpassword); err != nil {
		return nil, fmt.Errorf("incorrect password, Can't make changes without you old Password")
	}
	// Verify the provided password against the hashed password in the database

	// Update the leader's profile with the provided input fields.
	if input.Name != nil {
		leader.Name = *input.Name
	}
	if input.Email != nil {
		leader.Email = *input.Email
	}
	if input.PhoneNumber != nil {
		PhoneNumber := schemas.CleanPhoneNumber(*input.PhoneNumber)
		leader.PhoneNumber = &PhoneNumber
	}

	if input.Password != nil {
		// Hash and update the password if a new password is provided.
		password, err := helpers.HashPassword(*input.Password)
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %w", err)
		}
		leader.Password = &password
	}

	if input.Location != nil {
		leader.Location = input.Location
	}

	// Save the updated leader to the database.
	if err := r.DB.Save(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to save updated leader: %w", err)
	}

	return leader, nil
}

// UpdatesubChurch is the resolver for the updatesubChurch field.
func (r *mutationResolver) UpdatesubChurch(ctx context.Context, input model.UpdateLeaderProfileInput, subChurchID string) (*model.SubChurch, error) {
	leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("sub Church ID not found in request context")
	}
	// Check if the authenticated user is the same as the member being updated.
	if leaderID != subChurchID {
		return nil, fmt.Errorf("unauthorized: you can only update your own profile")
	}
	// Fetch the leader from the database using memberID.
	leader := &model.SubChurch{}
	if err := r.DB.First(leader, "id = ?", leaderID).Error; err != nil {
		return nil, fmt.Errorf("leader not found: %w", err)
	}

	// Verify the provided password against the hashed password in the database
	if err := helpers.VerifyPassword(*leader.Password, *input.Oldpassword); err != nil {
		return nil, fmt.Errorf("incorrect password, Can't make changes without you old Password")
	}

	// Update the leader's profile with the provided input fields.
	if input.Name != nil {
		leader.Name = *input.Name
	}
	if input.Email != nil {
		leader.Email = input.Email
	}

	if input.Password != nil {
		// Hash and update the password if a new password is provided.
		password, err := helpers.HashPassword(*input.Password)
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %w", err)
		}
		leader.Password = &password
	}

	// Save the updated leader to the database.
	if err := r.DB.Save(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to save updated leader: %w", err)
	}

	return leader, nil
}

// CreateChurch is the resolver for the createChurch field.
func (r *mutationResolver) CreateChurch(ctx context.Context, name string, email string, password *string) (*model.Church, error) {
	// Check if an email already exists
	existingChurch := &model.Church{}
	err := r.DB.Where("email = ?", email).First(existingChurch).Error
	if err == nil {
		return nil, fmt.Errorf("email already exists")
	} else if !errors.Is(err, gorm.ErrRecordNotFound) {
		return nil, err
	}

	// Hash the password
	hpassword, err := helpers.HashPassword(*password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}
	Types := "Admin"

	// Create a new church record
	newChurch := &model.Church{
		Name:     name,
		Password: &hpassword,
		Email:    &email,
		Types:    &Types,
	}

	if err := r.DB.Create(newChurch).Error; err != nil {
		return nil, fmt.Errorf("failed to create church: %v", err)
	}

	// Generate a token
	token, err := helpers.GenerateToken(Types, newChurch.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %v", err)
	}
	newChurch.Token = &token

	return newChurch, nil
}

// DeleteChurch is the resolver for the deleteChurch field.
func (r *mutationResolver) DeleteChurch(ctx context.Context, mainChurchID string) (bool, error) {
	UUID, err := uuid.Parse(mainChurchID)
	if err != nil {
		return false, fmt.Errorf("invalid ID: %w", err)
	}

	church := &model.Church{}

	if err := r.DB.Where("id = ?", UUID).First(&church).Error; err != nil {
		return false, err
	}

	// Delete the church from the database
	if err := r.DB.Delete(church).Error; err != nil {
		return false, err
	}
	return true, nil
}

// DeleteMember is the resolver for the deleteMember field.
func (r *mutationResolver) DeleteMember(ctx context.Context, memberID string) (bool, error) {
	member := &model.Member{}

	if err := r.DB.Where("id = ?", memberID).First(&member).Error; err != nil {
		return false, err
	}

	// Delete the member from the database
	if err := r.DB.Delete(member).Error; err != nil {
		return false, err
	}
	return true, nil
}

// DeleteSubChurch is the resolver for the deleteSubChurch field.
func (r *mutationResolver) DeleteSubChurch(ctx context.Context, subChurchID string) (bool, error) {
	subChurch := &model.SubChurch{}

	if err := r.DB.Where("id = ?", subChurchID).First(&subChurch).Error; err != nil {
		return false, err
	}

	// Delete the subChurch from the database
	if err := r.DB.Delete(subChurch).Error; err != nil {
		return false, err
	}
	return true, nil
}

// DeleteAllMembersBySubChurch is the resolver for the deleteAllMembersBySubChurch field.
func (r *mutationResolver) DeleteAllMembersBySubChurch(ctx context.Context, subChurchID string) (bool, error) {
	// Find all members with the specified SubChurchID
	members := []model.Member{}
	if err := r.DB.Where("sub_church_id = ?", subChurchID).Find(&members).Error; err != nil {
		return false, err
	}

	// Delete each member
	for _, member := range members {
		if err := r.DB.Delete(&member).Error; err != nil {
			return false, err
		}
	}

	return true, nil
}

// DeleteRegistration is the resolver for the deleteRegistration field.
func (r *mutationResolver) DeleteRegistration(ctx context.Context, registrationID string) (bool, error) {
	// // Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	// err := middleware.ExtractCTXinfo(ctx)
	// if err != nil {
	// 	return false, err
	// }
	UUID, err := uuid.Parse(registrationID)
	if err != nil {
		return false, fmt.Errorf("invalid leaderID: %w", err)
	}

	registration := &model.Registration{}

	if err := r.DB.Where("id = ?", UUID).First(&registration).Error; err != nil {
		return false, err
	}

	// Delete the registration from the database
	if err := r.DB.Delete(registration).Error; err != nil {
		return false, err
	}
	return true, nil
}

// CreateSubChurch is the resolver for the createSubChurch field.
func (r *mutationResolver) CreateSubChurch(ctx context.Context, subChurchName *string, branch bool, isLocal *bool) (*model.Church, error) {
	mainChurchID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("main ChurchID not found in request context")
	}
	// Convert subChurchName to uppercase
	uppercasedSubChurchName := ""
	if subChurchName != nil {
		uppercasedSubChurchName = strings.ToUpper(*subChurchName)
	}
	mainChurch := &model.Church{}

	// Find the main church by ID failed to find main church
	var church model.Church
	if err := r.DB.First(&church, "id = ?", mainChurchID).Error; err != nil {
		return nil, fmt.Errorf("failed to find main church in subChurch: %w", err)

	}

	// Check if the sub-church already exists
	if err := r.DB.Where("name = ? AND church_id = ?", uppercasedSubChurchName, mainChurchID).First(&model.SubChurch{}).Error; err == nil {
		return nil, fmt.Errorf("sub-church with the same name already exists")
	}

	Types := "subChurch"

	randomPassword := helpers.GenerateRandomPassword(6)
	// Hash the password
	hpassword, err := helpers.HashPassword(randomPassword)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}
	randomEmail := helpers.GenerateRandomEmail("envcare.com", randomPassword)
	// Create the sub-church and associate it with the main church
	subChurch := &model.SubChurch{
		Name:     uppercasedSubChurchName,
		ChurchID: mainChurchID,
		Email:    &randomEmail,
		Password: &hpassword,
		Types:    &Types,
	}

	if err := r.DB.Create(subChurch).Error; err != nil {
		return nil, fmt.Errorf("failed to create sub-church: %w", err)
	}

	// Generate a token
	token, err := helpers.GenerateToken(Types, subChurch.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %v", err)
	}
	subChurch.Token = &token
	// Append the sub-church to the main church's SubChurches slice
	mainChurch.SubChurches = append(mainChurch.SubChurches, subChurch)

	leadertype := []string{"Leader"}
	leaderpassword := "pass"
	leaderemail := "leader@gmail.com"

	// Generate random phone numbers
	randomPhoneNumber := func() string {
		return fmt.Sprintf("05%02d%03d", rand.Intn(100), rand.Intn(1000))
	}

	password, err := helpers.HashPassword(leaderpassword)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	subChurchIDStr := subChurch.ID.String() // Convert subChurch.ID to a string
	phoneNumber := randomPhoneNumber()      // Generate a random phone number for the leader

	leader := &model.Member{
		Name:  fmt.Sprintf("%s Leader", uppercasedSubChurchName),
		Email: leaderemail,

		Types:       leadertype,
		PhoneNumber: &phoneNumber,
		Password:    &password, // Set the leader's password here
		Day:         "none",
		SubChurchID: &subChurchIDStr,
		// Set other leader properties as needed
	}

	if err := r.DB.Create(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to create leader: %w", err)
	}

	token, err = helpers.GenerateToken(leadertype[0], (leader.ID.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to generate tokens: %w", err)
	}

	leader.Token = &token // Set the leader's token here
	// Parse the UUID separately
	uuid, err := uuid.Parse(leader.ID.String())
	if err != nil {
		return nil, fmt.Errorf("invalid Leader ID: %w", err)
	}

	// Convert the UUID to string before assigning to LeaderID
	uuidString := uuid.String()
	leader.LeaderID = &uuidString

	if err := r.DB.Save(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to create leader: %w", err)
	}

	return mainChurch, nil
}

// CreateMianChurch is the resolver for the createMianChurch field.
func (r *mutationResolver) CreateMianChurch(ctx context.Context, subChurchName *string) (*model.Church, error) {
	mainChurchID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("main ChurchID not found in request context")
	}
	// Convert subChurchName to uppercase
	uppercasedSubChurchName := ""
	if subChurchName != nil {
		uppercasedSubChurchName = strings.ToUpper(*subChurchName)
	}
	mainChurch := &model.Church{}

	if err := r.DB.First(mainChurch, "id = ?", mainChurchID).Error; err != nil {
		return nil, fmt.Errorf("failed to find main church: %w", err)
	}

	// Check if the sub-church already exists
	if err := r.DB.Where("name = ? AND church_id = ?", uppercasedSubChurchName, mainChurchID).First(&model.SubChurch{}).Error; err == nil {
		return nil, fmt.Errorf("sub-church with the same name already exists")
	}

	Types := "subChurch"

	randomPassword := helpers.GenerateRandomPassword(6)
	// Hash the password
	hpassword, err := helpers.HashPassword(randomPassword)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}
	randomEmail := helpers.GenerateRandomEmail("envcare.com", randomPassword)
	// Create the sub-church and associate it with the main church
	subChurch := &model.SubChurch{
		Name:     uppercasedSubChurchName,
		ChurchID: mainChurchID,
		Email:    &randomEmail,
		Password: &hpassword,
		Types:    &Types,
	}

	if err := r.DB.Create(subChurch).Error; err != nil {
		return nil, fmt.Errorf("failed to create sub-church: %w", err)
	}

	// Generate a token
	token, err := helpers.GenerateToken(Types, subChurch.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %v", err)
	}
	subChurch.Token = &token
	// Append the sub-church to the main church's SubChurches slice
	mainChurch.SubChurches = append(mainChurch.SubChurches, subChurch)
	// Define the days of the week
	leaderDaysOfWeek := []string{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"}
	subLeaderDaysOfWeek := []string{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"}
	// Create 3 leaders
	leaderIndex := 0
	leadertype := "Leader"
	leaderpassword := "pass"
	leaderemail := "leader@gmail.com"

	// Generate random phone numbers
	randomPhoneNumber := func() string {
		return fmt.Sprintf("05%02d%03d", rand.Intn(100), rand.Intn(1000))
	}

	password, err := helpers.HashPassword(leaderpassword)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", schemas.ErrInvalidInput)
	}

	// Create 4 sub-leaders
	subLeaderIndex := 0
	subLeaderSubLeader := "SubLeader"
	const numberOfSubLeaders = 7

	for i := 0; i < numberOfSubLeaders; i++ {
		subChurchIDStr := subChurch.ID.String()
		phoneNumber := randomPhoneNumber()

		subLeader := &model.Member{
			Name:        fmt.Sprintf("%s SubLeader %d", uppercasedSubChurchName, i+1),
			Types:       []string{subLeaderSubLeader},
			PhoneNumber: &phoneNumber,
			Password:    &password,
			Email:       leaderemail,
			Day:         subLeaderDaysOfWeek[subLeaderIndex],
			SubChurchID: &subChurchIDStr,
			// Set other sub-leader properties as needed
		}

		if err := r.DB.Create(subLeader).Error; err != nil {
			return nil, fmt.Errorf("failed to create sub-leader: %w", err)
		}

		subLeaderIndex = (subLeaderIndex + 1) % len(subLeaderDaysOfWeek)

		token, err := helpers.GenerateToken(leadertype, subLeader.ID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to generate tokens: %w", err)
		}

		subLeader.Token = &token

		// Parse the UUID separately
		uuid, err := uuid.Parse(subLeader.ID.String())
		if err != nil {
			return nil, fmt.Errorf("invalid Leader ID: %w", err)
		}

		// Convert the UUID to string before assigning to LeaderID
		uuidString := uuid.String()
		subLeader.LeaderID = &uuidString

		if err := r.DB.Save(subLeader).Error; err != nil {
			return nil, fmt.Errorf("failed to create leader: %w", err)
		}
	}

	for i := 0; i < 7; i++ {
		subChurchIDStr := subChurch.ID.String() // Convert subChurch.ID to a string
		phoneNumber := randomPhoneNumber()      // Generate random phone number for leaders

		leader := &model.Member{
			Name:  fmt.Sprintf("%s Leader %d", uppercasedSubChurchName, i+1),
			Email: leaderemail,
			Types: []string{leadertype},
			// Types:       &leadertype,
			PhoneNumber: &phoneNumber,
			Password:    &password, // Set the leader's password here
			Day:         leaderDaysOfWeek[leaderIndex],
			SubChurchID: &subChurchIDStr,
			// Set other leader properties as needed
		}

		if err := r.DB.Create(leader).Error; err != nil {
			return nil, fmt.Errorf("failed to create leader: %w", err)
		}

		leaderIndex = (leaderIndex + 1) % len(leaderDaysOfWeek) // Rotate through days of the week
		token, err := helpers.GenerateToken(leadertype, (leader.ID.String()))
		if err != nil {
			return nil, fmt.Errorf("failed to generate tokens: %w", err)
		}

		// Find the leader for the new member's day using FindLeaderWithSameDay
		Seletedleader, err := schemas.FindLeaderWithSameDay(ctx, r.DB, leader.Day, *leader.SubChurchID)
		if err != nil {
			return nil, fmt.Errorf("failed to create member : ")
		}

		leader.Token = &token // Set the leader's token here
		// Parse the UUID separately
		uuid, err := uuid.Parse(Seletedleader.ID.String())
		if err != nil {
			return nil, fmt.Errorf("invalid Leader ID: %w", err)
		}
		// Convert the UUID to string before assigning to LeaderID
		uuidString := uuid.String()
		leader.LeaderID = &uuidString

		if err := r.DB.Save(leader).Error; err != nil {
			return nil, fmt.Errorf("failed to create leader: %w", err)
		}
	}
	return mainChurch, nil
}

// leader is the resolver for the assignLeader field.
func (r *mutationResolver) AssignLeader(ctx context.Context, input *model.AssignLeaderInput) (*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	// Fetch the member by ID from the database.
	member := &model.Member{}
	if err := r.DB.First(member, "id = ?", input.MemberID).Error; err != nil {
		return nil, err // Handle the error if the member is not found.
	}

	// Check if the input type already exists in member.Types.
	for _, existingType := range member.Types {
		if existingType == *input.Types {
			return nil, fmt.Errorf("member already has the '%s' type", *input.Types)
		}
	}

	// Validate the input.Types field.
	if input.Types != nil && (*input.Types == "Admin") {
		return nil, fmt.Errorf("cannot assign Admin role") // Return an error if the input.Types is "Admin."
	}
	// Validate the input.Types field.
	if input.Types != nil && (*input.Types != "SubLeader" && *input.Types != "CallAgent" && *input.Types != "Leader") {
		return nil, fmt.Errorf("invalid leadership role: %s", *input.Types)
	}

	if member.Password == nil {
		// Hash the input password if a password does not exist.
		password, err := helpers.HashPassword(*input.Password)
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %w", schemas.ErrInvalidInput)
		}
		member.Password = &password
	}

	// member.Types = input.Types
	member.Types = append(member.Types, *input.Types)
	// member.Types = input.Types

	token, err := helpers.GenerateToken(*input.Types, (member.ID.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to generate tokens: %w", err)
	}
	member.Token = &token

	// Save the updated member to the database.
	if err := r.DB.Save(member).Error; err != nil {
		return nil, err // Handle the error if there's an issue saving the member.
	}

	return member, nil
}

// AddAnotherType is the resolver for the addAnotherType field.
func (r *mutationResolver) AddAnotherType(ctx context.Context, memberID string, types *string) (*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}

	// Fetch the member by ID from the database.
	member := &model.Member{}
	if err := r.DB.First(member, "id = ?", memberID).Error; err != nil {
		return nil, err // Handle the error if the member is not found.
	}

	// Validate the types field.
	if types == nil {
		return nil, fmt.Errorf("types cannot be empty")
	}

	// Check if the specified type is valid.
	if *types == "Admin" {
		return nil, fmt.Errorf("cannot assign Admin role")
	}

	// Check if the specified type is one of the valid leadership roles.
	validRoles := []string{"SubLeader", "CallAgent", "Leader"}
	isValidRole := false
	for _, role := range validRoles {
		if *types == role {
			isValidRole = true
			break
		}
	}
	if !isValidRole {
		return nil, fmt.Errorf("invalid leadership role: %s", *types)
	}

	// You can add additional logic to update the member's roles based on the new types.
	// For example, append the new type to the existing roles.
	member.Types = append(member.Types, *types)
	// member.Types = types

	// Save the updated member to the database.
	if err := r.DB.Save(member).Error; err != nil {
		return nil, err // Handle the error if there's an issue saving the member.
	}

	return member, nil
}

// UpdateLeaderTypes is the resolver for the updateLeaderTypes field.
func (r *mutationResolver) UpdateLeaderTypes(ctx context.Context, id *string, tags []string) (*model.Member, error) {
	// Find the post in the database by its ID
	var Member model.Member
	if err := r.DB.Where("id = ?", id).First(&Member).Error; err != nil {
		return nil, err
	}

	// Create a map to store the tags to remove for efficient lookup
	tagsToRemoveMap := make(map[string]bool)
	for _, tag := range tags {
		tagsToRemoveMap[tag] = true
	}

	// Filter the existing tags, keeping only those not in the tagsToRemoveMap
	var updatedTags []string
	for _, existingTag := range Member.Types {
		if !tagsToRemoveMap[existingTag] {
			updatedTags = append(updatedTags, existingTag)
		}
	}

	// Update the Member's Tags field with the filtered tags
	Member.Types = updatedTags

	// Save the updated Member back to the database
	if err := r.DB.Save(&Member).Error; err != nil {
		return nil, err
	}

	return &Member, nil
}

// AssignMemberToLeaderbySubchurch is the resolver for the assignMemberToLeaderbySubchurch field.
func (r *mutationResolver) AssignMemberToLeaderbySubchurch(ctx context.Context, leaderID string, memberID string) (*model.Member, error) {
	// Check if the specified leader exists.
	var leader model.Member
	if err := r.DB.Where("id = ? AND types && ?", leaderID, pq.Array([]string{"Leader", "SubLeader"})).First(&leader).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("Leader with ID %s not found", leaderID)
		}
		return nil, fmt.Errorf("failed to query leader: %w", err)
	}

	// Find the member based on the provided memberID.
	var member model.Member
	if err := r.DB.Where("id = ?", memberID).First(&member).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("Member with ID %s not found", memberID)
		}
		return nil, fmt.Errorf("failed to query member: %w", err)
	}

	// Update the Member's fields with the input values if they are provided
	if leaderID != "" {
		member.LeaderID = &leaderID
	}

	// Save the updated member to the database using your preferred ORM.
	if err := r.DB.Save(&member).Error; err != nil {
		return nil, fmt.Errorf("failed to save member to the database: %w", err)
	}

	return &member, nil
}

// AssignLeaderMemberRegisterToAnotherLeader is the resolver for the assignLeaderMemberRegisterToAnotherLeader field.
func (r *mutationResolver) AssignLeaderMemberRegisterToAnotherLeader(ctx context.Context, sendToLeaderID string, sendFromLeaderID string) ([]*model.Registration, error) {
	// Retrieve the SubChurchID associated with the leaderID
	subChurchID, err := schemas.GetSubChurchIDForLeader(r.DB, sendFromLeaderID)
	if err != nil {
		return nil, err
	}
	createdRegistrations := []*model.Registration{}
	exceededRateLimitMembers := []string{} // Track members who exceeded the rate limit of 24 hours a  Leader can't create a register within 24 hours cause it has been give to a TempLeader
	var members []*model.Member

	if err := r.DB.Where("leader_id = ?", sendFromLeaderID).Find(&members).Error; err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, fmt.Errorf("invalid Leader or Can't find Leader: %w", err)
	}
	for _, registrationInput := range members {
		// Check if MemberID is a valid UUID
		_, err := uuid.Parse(sendToLeaderID)
		if err != nil {
			return nil, fmt.Errorf("invalid Leader: %w", err)
		}
		var member model.Member

		if err := r.DB.Model(&model.Member{}).
			Where("id = ?", registrationInput.ID).
			First(&member).
			Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, err
		}

		// Ensure that the member exists
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("member with ID %s does not exist", registrationInput.ID)
		}

		// Query the database to check for existing registrations within the past 24 hours
		var lastRegistrationTime time.Time
		if err := r.DB.Model(&model.Registration{}).
			Select("created_at").
			Where("member_id = ?", registrationInput.ID).
			First(&lastRegistrationTime).
			Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, err
		}
		// Calculate the time difference between now and the last registration
		timeSinceLastRegistration := time.Since(lastRegistrationTime)

		// Define the rate limit (24 hours)
		rateLimit := 24 * time.Hour

		// Check if the last registration was within the rate limit
		if timeSinceLastRegistration < rateLimit {
			exceededRateLimitMembers = append(exceededRateLimitMembers, member.Name) // Track the name of the member
			continue                                                                 // Skip creating a registration for this member
		}

		// Create a new Registration object using the input data
		registration := &model.Registration{
			MemberID:     registrationInput.ID.String(),
			TempLeaderID: &sendToLeaderID,
			SubChurchID:  &subChurchID,
		}
		// Update the fields with the new values

		// Save the registration to the database
		if err := r.DB.Create(registration).Error; err != nil {
			return nil, err
		}

		createdRegistrations = append(createdRegistrations, registration)
	}
	// Check if any members exceeded the rate limit and include their names in the error message
	if len(exceededRateLimitMembers) > 0 {
		return nil, fmt.Errorf(" %v Cannot create registrations due to the transfer to a Temporary Leader", exceededRateLimitMembers)
	}
	// Return the created registrations
	return createdRegistrations, nil
}

// TempLeadercreateRegistrationArray is the resolver for the tempLeadercreateRegistrationArray field.
func (r *mutationResolver) TempLeadercreateRegistrationArray(ctx context.Context, input []*model.CreateRegistrationInput, registrationID []*string) ([]*model.Registration, error) {
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	createdRegistrations := []*model.Registration{}

	for i, registrations := range input {
		// Fetch the existing registration from the database
		uuid, err := uuid.Parse(*registrationID[i])
		if err != nil {
			return nil, fmt.Errorf("invalid registrationID: %w", err)
		}
		registration := &model.Registration{}

		if err := r.DB.Where("id = ?", uuid).First(&registration).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return nil, fmt.Errorf("registration not found")
			}
			return nil, err
		}

		// Update the fields with the new values
		if registrations.Absence != nil {
			registration.Absence = *registrations.Absence
		}
		if registrations.Present != nil {
			registration.Present = *registrations.Present
		}
		// Save the updated registration to the database
		if err := r.DB.Save(registration).Error; err != nil {
			return nil, err
		}

		// Convert the GORM model to the GraphQL model and return
		createdRegistrations = append(createdRegistrations, registration)

	}
	return createdRegistrations, nil
}

// UpdateRegistrationArray is the resolver for the updateRegistrationArray field.
func (r *mutationResolver) UpdateRegistrationArray(ctx context.Context, input []*model.RegistrationArrayInputs) ([]*model.Registration, error) {
	// Extracting context information using middleware
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}

	// Create a slice to hold the updated registrations
	updatedRegistrations := []*model.Registration{}

	// Iterate over the input array
	for _, regInput := range input {
		// Check if RegistrationIDs is not nil
		if regInput.RegistrationIDs == "" {
			return nil, fmt.Errorf("RegistrationIDs is required in input")
		}

		// Parse the registration ID from the input
		uuid, err := uuid.Parse(regInput.RegistrationIDs)
		if err != nil {
			return nil, fmt.Errorf("invalid registrationID: %w", err)
		}

		// Fetch the existing registration from the database
		registration := &model.Registration{}
		if err := r.DB.Where("id = ?", uuid).First(&registration).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return nil, fmt.Errorf("registration not found")
			}
			return nil, err
		}

		// Update the fields with the new values
		if regInput.CreateInput != nil {
			if regInput.CreateInput.Absence != nil {
				registration.Absence = *regInput.CreateInput.Absence
			}
			if regInput.CreateInput.Present != nil {
				registration.Present = *regInput.CreateInput.Present
			}
			if regInput.CreateInput.LastComment != nil {
				registration.LastComment = *regInput.CreateInput.LastComment
			}
		}

		// Save the updated registration to the database
		if err := r.DB.Save(registration).Error; err != nil {
			return nil, err
		}

		// Append the updated registration to the slice
		updatedRegistrations = append(updatedRegistrations, registration)
	}

	// Return the slice of updated registrations
	return updatedRegistrations, nil
}

// RemoveLeader is the resolver for the removeLeader field.
func (r *mutationResolver) RemoveLeader(ctx context.Context, memberID string) (*model.Member, error) {
	// Fetch the member by ID from the database.
	member := &model.Member{}
	if err := r.DB.First(member, "id = ?", memberID).Error; err != nil {
		return nil, err // Handle the error if the member is not found.
	}

	// Check if the member is currently assigned as a leader.
	if member.Types != nil {
		// If the member is a leader, remove the leadership role.
		member.Types = nil
		member.Token = nil    // Optionally, clear the token to invalidate it.
		member.Password = nil // Optionally, clear the password to invalidate it.

		// Save the updated member to the database.
		if err := r.DB.Save(member).Error; err != nil {
			return nil, err // Handle the error if there's an issue saving the member.
		}

		return member, nil
	}

	return nil, fmt.Errorf("member is not currently assigned as a leader")
}

// CreateSubChurchesWithMainChurch is the resolver for the createSubChurchesWithMainChurch field.
func (r *mutationResolver) CreateSubChurchesWithMainChurch(ctx context.Context, mainChurchID string, subChurchNames []string) (*model.Church, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}

	// leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	// if !ok {
	// 	return nil, fmt.Errorf("leaderID not found in request context")
	// }

	// Find the main church by ID
	mainChurch := &model.Church{}
	if err := r.DB.First(mainChurch, "id = ?", mainChurchID).Error; err != nil {
		return nil, fmt.Errorf("failed to find main church: %w", err)
	}

	// Create sub-churches and associate them with the main church
	subChurches := make([]model.SubChurch, len(subChurchNames))
	for i, subChurchName := range subChurchNames {
		subChurches[i] = model.SubChurch{
			Name:     subChurchName,
			ChurchID: mainChurchID,
		}
	}
	if err := r.DB.Create(&subChurches).Error; err != nil {
		return nil, fmt.Errorf("failed to create sub-churches: %w", err)
	}

	return mainChurch, nil
}

// CreateRegistration is the resolver for the createRegistration field.
func (r *mutationResolver) CreateRegistration(ctx context.Context, memberID string, input model.CreateRegistrationInput) (*model.Registration, error) {
	// Check if memberID is a valid UUID
	_, err := uuid.Parse(memberID)
	if err != nil {
		return nil, fmt.Errorf("invalid memberID: %w", err)
	}

	// Query the database to check for existing registrations within the past 24 hours
	var lastRegistrationTime time.Time
	if err := r.DB.Model(&model.Registration{}).
		Select("created_at").
		Where("member_id = ?", memberID).
		Order("created_at DESC").
		First(&lastRegistrationTime).
		Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		return nil, err
	}

	// Calculate the time difference between now and the last registration
	timeSinceLastRegistration := time.Since(lastRegistrationTime)

	// Define the rate limit (24 hours)
	rateLimit := 24 * time.Hour

	// Check if the last registration was within the rate limit
	if timeSinceLastRegistration < rateLimit {
		return nil, fmt.Errorf("rate limit exceeded, you can create a registration again in %v", rateLimit-timeSinceLastRegistration)
	}

	// Create a new Registration object using the input data
	registration := &model.Registration{
		MemberID: memberID,
	}
	if input.LastComment != nil {
		registration.LastComment = *input.LastComment
	}

	if input.Absence != nil {
		registration.Absence = *input.Absence
	}

	if input.Present != nil {
		registration.Present = *input.Present
	}

	// Save the registration to the database
	if err := r.DB.Create(registration).Error; err != nil {
		return nil, err
	}

	// Return the created registration
	return registration, nil
}

// CreateRegistrationArray is the resolver for the createRegistrationArray field.
func (r *mutationResolver) CreateRegistrationArray(ctx context.Context, input []*model.RegistrationArrayInput) ([]*model.Registration, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("leaderID not found in request context")
	}
	// Retrieve the SubChurchID associated with the leaderID
	subChurchID, err := schemas.GetSubChurchIDForLeader(r.DB, leaderID)
	if err != nil {
		return nil, err
	}
	createdRegistrations := []*model.Registration{}
	exceededRateLimitMembers := []string{} // Track members who exceeded the rate limit of 24 hours a  Leader can't create a register within 24 hours

	for _, registrationInput := range input {
		// Check if MemberID is a valid UUID
		_, err := uuid.Parse(registrationInput.MemberID)
		if err != nil {
			return nil, fmt.Errorf("invalid MemberID: %w", err)
		}

		// Query the database to check if the member exists
		var member model.Member
		if err := r.DB.Model(&model.Member{}).
			Where("id = ?", registrationInput.MemberID).
			First(&member).
			Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, err
		}

		// Ensure that the member exists
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("member with ID %s does not exist", registrationInput.MemberID)
		}

		// Query the database to check for existing registrations within the past 24 hours
		var lastRegistrationTime time.Time
		if err := r.DB.Model(&model.Registration{}).
			Select("created_at").
			Where("member_id = ?", registrationInput.MemberID).
			Order("created_at DESC").
			First(&lastRegistrationTime).
			Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, err
		}

		// Calculate the time difference between now and the last registration
		timeSinceLastRegistration := time.Since(lastRegistrationTime)

		// Define the rate limit (24 hours)
		rateLimit := 24 * time.Hour

		// Check if the last registration was within the rate limit
		if timeSinceLastRegistration < rateLimit {
			exceededRateLimitMembers = append(exceededRateLimitMembers, member.Name) // Track the name of the member
			continue                                                                 // Skip creating a registration for this member
		}

		// Create a new Registration object using the input data
		registration := &model.Registration{
			MemberID:    registrationInput.MemberID,
			SubChurchID: &subChurchID,
		}
		if registrationInput.CreateInput.LastComment != nil {
			registration.LastComment = *registrationInput.CreateInput.LastComment
		}

		if registrationInput.CreateInput.Absence != nil {
			registration.Absence = *registrationInput.CreateInput.Absence
		}

		if registrationInput.CreateInput.Present != nil {
			registration.Present = *registrationInput.CreateInput.Present
		}

		// Save the registration to the database
		if err := r.DB.Create(registration).Error; err != nil {
			return nil, err
		}

		createdRegistrations = append(createdRegistrations, registration)
	}

	// Check if any members exceeded the rate limit and include their names in the error message
	if len(exceededRateLimitMembers) > 0 {
		return nil, fmt.Errorf(" %v Cannot create registrations within the specified time frame", exceededRateLimitMembers)
	}

	// Return the created registrations
	return createdRegistrations, nil
}

// UpdateRegistration is the resolver for the updateRegistration field.
func (r *mutationResolver) UpdateRegistration(ctx context.Context, input model.CreateRegistrationInput, registrationID string) (*model.Registration, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	// Fetch the existing registration from the database
	uuid, err := uuid.Parse(registrationID)
	if err != nil {
		return nil, fmt.Errorf("invalid registrationID: %w", err)
	}
	registration := &model.Registration{}

	if err := r.DB.Where("id = ?", uuid).First(&registration).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("registration not found")
		}
		return nil, err
	}

	// Update the fields with the new values
	if input.Absence != nil {
		registration.Absence = *input.Absence
	}
	if input.Present != nil {
		registration.Present = *input.Present
	}
	if input.LastComment != nil {
		registration.LastComment = *input.LastComment
	}

	// Save the updated registration to the database
	if err := r.DB.Save(registration).Error; err != nil {
		return nil, err
	}

	// Convert the GORM model to the GraphQL model and return
	return registration, nil
}

// UpdateRegistrationByLeader is the resolver for the updateRegistrationByLeader field.
func (r *mutationResolver) UpdateRegistrationByLeader(ctx context.Context, input model.CreateRegistrationInput, registrationID string, leaderID string) (*model.Registration, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	// Validate registrationID and leaderID as valid UUIDs
	registrationUUID, err := uuid.Parse(registrationID)
	if err != nil {
		return nil, fmt.Errorf("invalid registrationID: %w", err)
	}

	_, err = uuid.Parse(leaderID)
	if err != nil {
		return nil, fmt.Errorf("invalid leaderID: %w", err)
	}

	// Fetch the registration from the database
	register := &model.Registration{}

	if err := r.DB.Where("id = ?", registrationUUID).First(&register).Error; err != nil {
		// Handle the case when the registration is not found
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("registration not found")
		}
		return nil, err
	}

	// Check if the registration is associated with the provided leader ID
	if register.LeaderID != nil && *register.LeaderID != leaderID {
		return nil, fmt.Errorf("registration is not associated with the provided leader")
	}

	// Update the registration's attributes based on the input
	if input.Absence != nil {
		if *input.Absence {
			// If Absence is set to true, set Present to false
			register.Present = false
		}
		register.Absence = *input.Absence
	}

	if input.Present != nil {
		if *input.Present {
			// If Present is set to true, set Absence to false
			register.Absence = false
		}
		register.Present = *input.Present
	}
	if input.LastComment != nil && *input.LastComment != "" {
		register.LastComment = *input.LastComment
	}

	// Save the updated registration
	if err := r.DB.Save(register).Error; err != nil {
		return nil, err
	}

	return register, nil
}

// CreateCallCenterForSubChurchs is the resolver for the CreateCallCenterForSubChurchs field.
func (r *mutationResolver) CreateCallCenterForSubChurchs(ctx context.Context, name string, subChurchIDs []string) (*model.CallCenter, error) {
	// Validate inputs
	if name == "" {
		return nil, fmt.Errorf("name cannot be empty")
	}

	// // Assuming you have a middleware that provides the main church ID in the context
	// SubChurchID, ok := ctx.Value(middleware.IDContextKey).(string)
	// if !ok {
	// 	return nil, fmt.Errorf("SubChurch ID not found in request context")
	// }

	// // Retrieve the main church
	// SubChurch := &model.SubChurch{}
	// if err := r.DB.First(SubChurch, "church_id = ?", SubChurchID).Error; err != nil {
	// 	return nil, fmt.Errorf("failed to find main church: %w", err)
	// }

	Types := "callCenter"
	randomPassword := helpers.GenerateRandomPassword(6)
	// Hash the password
	hpassword, err := helpers.HashPassword(randomPassword)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}
	randomEmail := helpers.GenerateRandomEmail("envcare.com", randomPassword)

	// Create the call center
	callCenter := &model.CallCenter{
		Name:     name,
		Types:    &Types, // Assuming a default value for types
		Email:    &randomEmail,
		Password: &hpassword,
	}

	// Save the call center to get a valid ID
	if err := r.DB.Create(callCenter).Error; err != nil {
		return nil, fmt.Errorf("failed to create call center: %w", err)
	}

	callCenterID := callCenter.ID.String()

	// Associate the call center with sub-churches
	for _, subChurchID := range subChurchIDs {
		sub := &model.SubChurch{}
		if err := r.DB.First(sub, "id = ?", subChurchID).Error; err != nil {
			return nil, fmt.Errorf("failed to find sub-church with ID %s: %w", subChurchID, err)
		}

		sub.CallCenterID = &callCenterID

		// Save changes to the database
		if err := r.DB.Save(sub).Error; err != nil {
			return nil, fmt.Errorf("failed to save changes to the database: %w", err)
		}
	}

	return callCenter, nil
}

// DistributeRegistrationsToLeaders is the resolver for the distributeRegistrationsToLeaders field.
func (r *mutationResolver) DistributeRegistrationsToLeaders(ctx context.Context, leaderIds []string) ([]*model.LeaderRegistrationsDistribution, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo4CallCenter(ctx)
	if err != nil {
		return nil, err
	}
	// Fetch the current week's registrations
	currentWeekRegistrations, err := r.Query().CurrentWeekRegistrations(ctx)
	if err != nil {
		return nil, err
	}

	// Shuffle the leader IDs using your shuffling algorithm
	schemas.ShuffleLeaders(leaderIds)

	// Create a map to store registration IDs for each leader
	leaderRegistrationMap := make(map[string][]string)

	// Distribute registration IDs among shuffled leader IDs
	for i, reg := range currentWeekRegistrations {
		leaderIndex := i % len(leaderIds)
		leaderID := leaderIds[leaderIndex]
		leaderRegistrationMap[leaderID] = append(leaderRegistrationMap[leaderID], reg.ID.String())

		// Convert leaderID (string) to uuid.UUID
		_, err := uuid.Parse(leaderID)
		if err != nil {
			return nil, err // Handle the error appropriately
		}

		// Update the registration's LeaderID with the converted uuid.UUID
		reg.LeaderID = &leaderID // Update this line
		if err := r.DB.Save(&reg).Error; err != nil {
			return nil, err
		}
	}

	// Create the final response structure
	var leaderDistribution []*model.LeaderRegistrationsDistribution
	for leaderID, regIDs := range leaderRegistrationMap {
		leaderDist := &model.LeaderRegistrationsDistribution{
			LeaderID:        leaderID,
			RegistrationIDs: regIDs,
		}
		leaderDistribution = append(leaderDistribution, leaderDist)
	}

	return leaderDistribution, nil
}

// ReportRegistrationByLeader is the resolver for the ReportRegistrationByLeader field.
func (r *mutationResolver) ReportRegistrationByLeader(ctx context.Context, report *model.ReportRegistrationInput, registrationID string, leaderID string) (*model.Registration, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}

	registrationUUID, err := uuid.Parse(registrationID)
	if err != nil {
		return nil, fmt.Errorf("invalid registrationID: %w", err)
	}

	_, err = uuid.Parse(leaderID)
	if err != nil {
		return nil, fmt.Errorf("invalid leaderID: %w", err)
	}

	// Fetch the registration from the database
	register := &model.Registration{}

	if err := r.DB.Where("id = ?", registrationUUID).
		Preload("Leader").
		Preload("Member"). // Preload the Member field
		First(&register).Error; err != nil {
		// Handle the case when the registration is not found
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("registration not found")
		}
		return nil, fmt.Errorf("failed to Fetch the registration: %w", err)
	}

	// Check if the registration is associated with the provided leader ID
	if register.LeaderID != nil && *register.LeaderID != leaderID {
		return nil, fmt.Errorf("registration is not associated with the provided leader")
	}

	// Update the fields with the input values if they are provided
	if report != nil {
		register.Report = report.Report
	}
	if report.Done != nil {
		register.Done = report.Done
	}

	// Save the updated registration
	if err := r.DB.Save(register).Error; err != nil {
		return nil, fmt.Errorf("failed to save registration: %w", err)
	}

	return register, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginLeaderInput) (model.Returns, error) {
	clear := model.RemoveSpacesFromNumber(*input.Email)
	if model.IsValidEmail(clear) {
		// Fetch the leader from the database based on the provided email
		leader := &model.Church{}
		sub := &model.SubChurch{}
		callCenter := &model.CallCenter{}

		// Check if it's an admin leader
		if err := r.DB.Where("email = ?", clear).First(leader).Error; err == nil {
			if *leader.Types == "Admin" {
				// Verify the provided password against the hashed password in the database
				if err := helpers.VerifyPassword(*leader.Password, input.Password); err != nil {
					return nil, fmt.Errorf("invalid password")
				}
				// Generate a new token for the authenticated leader
				token, err := helpers.GenerateToken(*leader.Types, leader.ID.String())
				if err != nil {
					return nil, fmt.Errorf("failed to generate token")
				}
				// Update the leader's token with the newly generated token
				leader.Token = &token

				// Save the updated leader with the token to the database
				if err := r.DB.Save(leader).Error; err != nil {
					return nil, fmt.Errorf("failed to save leader's token to the database")
				}

				// Retrieve the CookieAccess object from the context
				ca := middleware.GetCookieAccess(ctx)

				// Set the generated token as a cookie using the CookieAccess object
				ca.SetToken(token)

				return leader, nil
			}
		} else if err := r.DB.Where("email = ?", clear).First(sub).Error; err == nil {
			if *sub.Types == "subChurch" {
				// Verify the provided password against the hashed password in the database
				if err := helpers.VerifyPassword(*sub.Password, input.Password); err != nil {
					return nil, fmt.Errorf("invalid password")
				}
				// Generate a new token for the authenticated sub
				token, err := helpers.GenerateToken(*sub.Types, sub.ID.String())
				if err != nil {
					return nil, fmt.Errorf("failed to generate token")
				}
				// Update the sub's token with the newly generated token
				sub.Token = &token

				// Save the updated sub with the token to the database
				if err := r.DB.Save(sub).Error; err != nil {
					return nil, fmt.Errorf("failed to save sub's token to the database")
				}

				// Retrieve the CookieAccess object from the context
				ca := middleware.GetCookieAccess(ctx)

				// Set the generated token as a cookie using the CookieAccess object
				ca.SetToken(token)

				return sub, nil
			}
		} else if err := r.DB.Where("email = ?", clear).Preload("SubChurches").First(callCenter).Error; err == nil {
			if *callCenter.Types == "callCenter" {
				// Verify the provided password against the hashed password in the database
				if err := helpers.VerifyPassword(*callCenter.Password, input.Password); err != nil {
					return nil, fmt.Errorf("invalid password")
				}
				// Generate a new token for the authenticated callCenter
				token, err := helpers.GenerateToken(*callCenter.Types, callCenter.ID.String())
				if err != nil {
					return nil, fmt.Errorf("failed to generate token")
				}
				// Update the callCenter's token with the newly generated token
				callCenter.Token = &token

				// Save the updated callCenter with the token to the database
				if err := r.DB.Save(callCenter).Error; err != nil {
					return nil, fmt.Errorf("failed to save callCenter's token to the database")
				}

				// Retrieve the CookieAccess object from the context
				ca := middleware.GetCookieAccess(ctx)

				// Set the generated token as a cookie using the CookieAccess object
				ca.SetToken(token)

				return callCenter, nil
			}
		}
		return nil, fmt.Errorf("email not found or invalid login input")
	} else if model.IsNumeric(clear) {
		leader := &model.Member{}
		if err := r.DB.Where("phone_number = ?", clear).First(leader).Error; err != nil {
			return nil, fmt.Errorf("leader not found")
		}
		// Verify the provided password against the hashed password in the database
		if err := helpers.VerifyPassword(*leader.Password, input.Password); err != nil {
			return nil, fmt.Errorf("invalid password")
		}
		// Generate a new token for the authenticated leader
		token, err := helpers.GenerateToken(leader.Types[0], leader.ID.String())
		// token, err := helpers.GenerateToken(*leader.Types, leader.ID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to generate token")
		}
		// Update the leader's token with the newly generated token
		leader.Token = &token

		// Save the updated leader with the token to the database
		if err := r.DB.Save(leader).Error; err != nil {
			return nil, fmt.Errorf("failed to save leader's token to the database")
		}

		// Retrieve the CookieAccess object from the context
		ca := middleware.GetCookieAccess(ctx)

		// Set the generated token as a cookie using the CookieAccess object
		ca.SetToken(token)

		return leader, nil
	}
	return nil, fmt.Errorf("invalid login input")
}

// Memberlogin is the resolver for the memberlogin field.
func (r *mutationResolver) Memberlogin(ctx context.Context, input model.LoginLeaderInput) (model.Returns, error) {
	leader := &model.Member{}
	if err := r.DB.Where("phone_number = ?", input.Email).First(leader).Error; err != nil {
		return nil, fmt.Errorf("leader not found")
	}
	// Verify the provided password against the hashed password in the database
	if err := helpers.VerifyPassword(*leader.Password, input.Password); err != nil {
		return nil, fmt.Errorf("invalid password")
	}

	// Generate a new token for the authenticated leader
	token, err := helpers.GenerateToken(leader.Types[0], leader.ID.String())
	// token, err := helpers.GenerateToken(*leader.Types, leader.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}
	// Update the leader's token with the newly generated token
	leader.Token = &token

	// Save the updated leader with the token to the database
	if err := r.DB.Save(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to save leader's token to the database")
	}

	// Retrieve the CookieAccess object from the context
	ca := middleware.GetCookieAccess(ctx)

	// Set the generated token as a cookie using the CookieAccess object
	ca.SetToken(token)

	return leader, nil
}

// LogOut is the resolver for the logOut field.
func (r *mutationResolver) LogOut(ctx context.Context) (bool, error) {
	// Assuming you have access to the CookieAccess object from the context
	cookieAccess := middleware.GetCookieAccess(ctx)

	// Call the Logout method to clear the user's session cookie
	err := cookieAccess.Logout()
	if err != nil {
		// Handle the error, e.g., log it or return an appropriate GraphQL error
		return false, err
	}

	// You can also perform any other logout-related actions here,
	// such as invalidating tokens, revoking access, etc.

	// Return true to indicate a successful logout
	return true, nil
}

// GetAllMainChurch is the resolver for the GetAllMainChurch field.
func (r *queryResolver) GetAllMainChurch(ctx context.Context) ([]*model.Church, error) {
	var churchs []*model.Church
	if err := r.DB.Find(&churchs).Order("created_at DESC").Error; err != nil {
		return nil, err
	}

	return churchs, nil
}

// GetsubChurchByMainChurchID is the resolver for the GetsubChurchByMainChurchID field.
func (r *queryResolver) GetAllsubChurchByMainChurchID(ctx context.Context, mainChurchID string) ([]*model.SubChurch, error) {
	var subChurch []*model.SubChurch
	if err := r.DB.Where("church_id = ?", mainChurchID).Preload("Church").Order("created_at DESC").Find(&subChurch).Error; err != nil {
		return nil, err
	}

	return subChurch, nil
}

// GetAllsubChurchByMemberID is the resolver for the GetAllsubChurchByMemberId field.
func (r *queryResolver) GetAllsubChurchByMemberID(ctx context.Context, memberID string) ([]*model.SubChurch, error) {
	// Find the Member and its associated SubChurch
	member := model.Member{}
	if err := r.DB.Where("id = ?", memberID).Preload("SubChurch").Find(&member).Error; err != nil {
		return nil, err
	}

	if member.SubChurch == nil {
		return nil, fmt.Errorf("Member is not associated with a SubChurch")
	}

	// Find the Church and its associated SubChurches
	church := model.Church{}
	if err := r.DB.Where("id = ?", member.SubChurch.ChurchID).Preload("SubChurches").Order("created_at DESC").Find(&church).Error; err != nil {
		return nil, err
	}

	// Return the list of SubChurches associated with the Church
	return church.SubChurches, nil
}

// GetAllMembersBySubChurchID is the resolver for the GetAllMembersBySubChurchID field.
func (r *queryResolver) GetAllMembersBySubChurchID(ctx context.Context, subChurchID string) ([]*model.Member, error) {
	var members []*model.Member
	if err := r.DB.Where("sub_church_id = ?", subChurchID).Preload("SubChurch").Order("created_at DESC").Find(&members).Error; err != nil {
		log.Printf("Error executing SQL query: %v", err)
		return nil, fmt.Errorf(" Error executing SQL query: %w", err)
	}

	// Convert pq.StringArray to []string
	for _, member := range members {
		member.Types = []string(member.Types)
	}
	return members, nil
}

// GetAllSubChurchLeader is the resolver for the GetAllSubChurchLeader field.
func (r *queryResolver) GetAllSubChurchLeader(ctx context.Context, subChurchID string) (*model.Member, error) {
	var leader model.Member

	if err := r.DB.Where("sub_church_id = ? AND types && ?", subChurchID, pq.Array([]string{"Leader"})).Order("created_at DESC").Find(&leader).Error; err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}
	return &leader, nil
}

// GetAllMembersByLeader is the resolver for the GetAllMembersByLeader field.
func (r *queryResolver) GetAllMembersByLeader(ctx context.Context, leaderID string) ([]*model.Member, error) {
	var members []*model.Member

	if err := r.DB.Where("leader_id = ?", leaderID).Preload("SubChurch").Order("created_at DESC").Find(&members).Error; err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}

	return members, nil
}

// GetAllSubLeaderByLeader is the resolver for the GetAllSubLeaderByLeader field.
func (r *queryResolver) GetAllSubLeaderByLeader(ctx context.Context, subChurchID string, day string) ([]*model.Member, error) {
	var members []*model.Member

	// var members []*model.Member

	if err := r.DB.Where("types IN (?) AND day = ? AND sub_church_id = ?", pq.Array([]string{"SubLeader"}), day, subChurchID).Preload("SubChurch").Order("created_at DESC").Find(&members).Error; err != nil {
		// Handle errors here, such as if no leaders with the same day are found.
		return nil, err
	}
	return members, nil
}

// GetAllMemberBySubLeaderToLeader is the resolver for the GetAllMemberBySubLeaderToLeader field.
func (r *queryResolver) GetAllMemberBySubLeaderToLeader(ctx context.Context, subChurchID string, day string) ([]*model.Member, error) {
	var members []*model.Member

	if err := r.DB.Where("day = ? AND sub_church_id = ?", day, subChurchID).Preload("Leader").Preload("SubChurch").Order("created_at DESC").Find(&members).Error; err != nil {
		// Handle errors here, such as if no leaders with the same day are found.
		return nil, err
	}
	return members, nil
}

// GetNoteficationByLeader is the resolver for the GetNoteficationByLeader field.
func (r *queryResolver) GetNoteficationByLeader(ctx context.Context, subChurchID string, day *string) ([]*model.Member, error) {
	currentWeekNumber := schemas.GetWeekNumber(time.Now())

	// Step 1: Fetch all sub-leaders based on specified conditions
	var subLeaders []*model.Member
	if err := r.DB.
		Where("types IN (?) AND day = ? AND sub_church_id = ?", pq.Array([]string{"SubLeader"}), day, subChurchID).
		Find(&subLeaders).
		Error; err != nil {
		// Handle errors here, such as if no sub-leaders are found.
		return nil, err
	}

	// Step 2: Extract IDs of sub-leaders and log them
	var subLeaderIDs []string
	for _, subLeader := range subLeaders {
		subLeaderIDs = append(subLeaderIDs, subLeader.ID.String())
	}

	// Step 3: Query sub-leaders with their registrations for the current week
	var filteredSubLeadersMembers []*model.Member
	if err := r.DB.
		Model(&model.Member{}).
		Where("leader_id IN (?)", subLeaderIDs).
		Preload("Registrations", "report IS NOT NULL AND report = true AND EXTRACT(WEEK FROM created_at) = ?", currentWeekNumber).
		Order("created_at DESC").
		Find(&filteredSubLeadersMembers).
		Error; err != nil {
		return nil, err
	}

	// Step 4: Filter out sub-leaders with empty registrations
	var result []*model.Member
	for _, subLeader := range filteredSubLeadersMembers {
		var filteredRegistrations []*model.Registration
		for _, registration := range subLeader.Registrations {
			// Check if the Report field is not nil and is true
			isTrue := true
			if registration.Report != nil && *registration.Report == isTrue {
				filteredRegistrations = append(filteredRegistrations, registration)
			}
		}

		// Only include sub-leaders with at least one registration where report is true
		if len(filteredRegistrations) > 0 {
			// Clone the subLeader to avoid modifying the original slice
			clonedSubLeader := *subLeader
			clonedSubLeader.Registrations = filteredRegistrations
			result = append(result, &clonedSubLeader)
		}
	}

	return result, nil
}

// GetAllRegistersByMemberID is the resolver for the GetAllRegistersByMemberID field.
func (r *queryResolver) GetAllRegistersByMemberID(ctx context.Context, memberID string) ([]*model.Registration, error) {
	var Registrations []*model.Registration
	if err := r.DB.Where("member_id = ?", memberID).Preload("Member").Order("created_at DESC").Find(&Registrations).Error; err != nil {
		return nil, err
	}
	// Fetch LeaderNames based on LeaderIDs or set to "No Assign Caller" if LeaderID is nil
	for _, reg := range Registrations {
		if reg.LeaderID != nil {
			leaderMember := &model.Member{} // Assuming Leader is also a Member
			if err := r.DB.Where("id = ?", *reg.LeaderID).First(leaderMember).Error; err == nil {
				reg.LeaderName = &leaderMember.Name // Assuming you have a Name field in the Member model
			}
		} else {
			// Set LeaderName to "No Assign Caller" in the database when LeaderID is nil
			if err := r.DB.Model(&reg).Update(" LeaderName", "No Assign Caller").Error; err != nil {
				// Handle the error if needed
			}
		}
	}

	return Registrations, nil
}

// LastFourCommentsForMember is the resolver for the LastFourCommentsForMember field.
func (r *queryResolver) LastFourCommentsForMember(ctx context.Context, memberID string) ([]*string, error) {
	// Query the database for the last 4 registrations
	var Registrations []*model.Registration
	if err := r.DB.
		Where("member_id = ?", memberID).
		Order("created_at DESC").
		Limit(4). // Limit the result to the last 4 entries
		Find(&Registrations).
		Error; err != nil {
		return nil, err
	}

	// Extract the last 4 `lastComment` values as pointers to strings
	var comments []*string
	for _, reg := range Registrations {
		comment := reg.LastComment
		comments = append(comments, &comment)
	}

	return comments, nil
}

// GetAllsubChurch is the resolver for the GetAllsubChurch field.
func (r *queryResolver) GetAllsubChurch(ctx context.Context) ([]*model.SubChurch, error) {
	var sub []*model.SubChurch
	if err := r.DB.Preload("Members").Order("created_at DESC").Find(&sub).Error; err != nil {
		fmt.Println(" Error preloading associations:", err)
		return nil, err
	}

	return sub, nil
}

// GetCallCenter is the resolver for the GetCallCenter field.
func (r *queryResolver) GetCallCenter(ctx context.Context) ([]*model.CallCenter, error) {
	var callCenters []*model.CallCenter

	// Use Preload to include the SubChurches relationship
	if err := r.DB.Preload("SubChurches").Order("created_at DESC").Find(&callCenters).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch Call Centers: %w", err)
	}

	return callCenters, nil
}

// GetAllSubChurchByCallCenter is the resolver for the GetAllSubChurchByCallCenter field.
func (r *queryResolver) GetAllSubChurchByCallCenter(ctx context.Context, callCenterID string) ([]*model.SubChurch, error) {
	UUID, err := uuid.Parse(callCenterID)
	if err != nil {
		return nil, fmt.Errorf("invalid ID: %w", err)
	}
	// Find the Member and its associated SubChurch
	var sub []*model.SubChurch
	if err := r.DB.Where("call_center_id = ?", UUID).Order("created_at DESC").Find(&sub).Error; err != nil {
		return nil, err
	}

	return sub, nil
}

// GetCaller is the resolver for the GetCaller field.
func (r *queryResolver) GetCaller(ctx context.Context) ([]*model.Member, error) {
	var leaders []*model.Member
	// pq.Array([]string{"Leader", "SubLeader"})
	// Query the database to retrieve leaders with Types equal to "Caller" or "Admin"
	// if err := r.DB.Where("types IN (?)", []string{"CallAgent"}).Find(&leaders).Error; err != nil
	// if err := r.DB.Where("?'CallAgent'", "types").Find(&leaders).Error; err != nil
	if err := r.DB.Where("? = ANY(types)", "CallAgent").Order("created_at DESC").Find(&leaders).Error; err != nil {

		return nil, fmt.Errorf("failed to fetch leaders: %w", err)
	}

	return leaders, nil
}

// GetCallAgent is the resolver for the GetCallAgent field.
func (r *queryResolver) GetCallAgent(ctx context.Context) ([]*model.Member, error) {
	var leaders []*model.Member

	// types := []string{"CallAgent"}

	if err := r.DB.WithContext(ctx).
		Where("? = ANY(types)", "CallAgent").
		Preload("SubChurch").
		Order("created_at DESC").
		Find(&leaders).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch leaders: %w", err)
	}

	return leaders, nil
}

// Getmember is the resolver for the Getmember field.
func (r *queryResolver) Getmember(ctx context.Context, id string) (*model.Member, error) {
	var Member model.Member

	// Use GORM to find the Member by its ID
	if err := r.DB.Where("id = ?", id).Preload("SubChurch").First(&Member).Error; err != nil {
		return nil, err
	}

	return &Member, nil
}

// GetMigration is the resolver for the GetMigration field.
func (r *queryResolver) GetMigration(ctx context.Context, id string) (*model.MigrationRequest, error) {
	var migrate model.MigrationRequest

	// Use GORM to find the migrate by its ID
	if err := r.DB.Where("id = ?", id).First(&migrate).Error; err != nil {
		return nil, err
	}

	return &migrate, nil
}

// GetMigrationdestinationID is the resolver for the GetMigrationdestinationID field.
func (r *queryResolver) GetMigrationdestinationID(ctx context.Context, destinationChurchID string) ([]*model.MigrationRequest, error) {
	var migrationRequests []*model.MigrationRequest

	// Use GORM to query the database for migration requests with the given destinationChurchID and order them by CreatedAt in descending order
	if err := r.DB.Where("destination_church_id = ?", destinationChurchID).Order("created_at DESC").Find(&migrationRequests).Error; err != nil {
		return nil, err
	}

	return migrationRequests, nil
}

// Getmembers is the resolver for the Getmembers field.
func (r *queryResolver) Getmembers(ctx context.Context) ([]*model.Member, error) {
	var leaders []*model.Member

	// Query the database to retrieve leaders with Types equal to "Caller" or "Admin"
	if err := r.DB.Find(&leaders).Order("created_at DESC").Error; err != nil {
		return nil, fmt.Errorf("failed to fetch leaders: %w", err)
	}

	return leaders, nil
}

// TodaysMembers is the resolver for the todaysMembers field.
func (r *queryResolver) TodaysMembers(ctx context.Context) ([]*model.Member, error) {
	// Implement logic to retrieve both today's and yesterday's members.

	today := time.Now()
	yesterday := today.AddDate(0, 0, -1)

	var members []*model.Member

	// Assuming you have a database or data source, you can query members created on both today and yesterday.
	if err := r.DB.Where("created_at >= ? AND created_at < ?", yesterday, today.AddDate(0, 0, 1)).Order("created_at DESC").Find(&members).Error; err != nil {
		return nil, err
	}

	return members, nil
}

// GetsubChurchByID is the resolver for the GetsubChurchByID field.
func (r *queryResolver) GetsubChurchByID(ctx context.Context, id string) (*model.SubChurch, error) {
	var sub model.SubChurch

	// Use GORM to find the sub by its ID
	if err := r.DB.Where("id = ?", id).First(&sub).Error; err != nil {
		return nil, err
	}

	return &sub, nil
}

// MembersBySubChurchID is the resolver for the MembersBySubChurchID field.
func (r *queryResolver) MembersBySubChurchID(ctx context.Context, subChurchID string) ([]*model.Member, error) {
	var members []*model.Member
	if err := r.DB.
		Where("sub_church_id = ?", subChurchID).Preload("Registrations").Preload("Church").Order("created_at DESC").Find(&members).Error; err != nil {
		fmt.Println("Error preloading associations:", err)
		return nil, err
	}

	return members, nil
}

// RegistrationsByLeader is the resolver for the registrationsByLeader field.
func (r *queryResolver) RegistrationsByLeader(ctx context.Context, mleaderID string) ([]*model.Registration, error) {
	var registrations []*model.Registration

	// Preload the Leader and member associations
	if err := r.DB.Where("leader_id = ?", mleaderID).
		Preload("Leader").
		Preload("Member.SubChurch").
		Order("created_at DESC").
		Find(&registrations).Error; err != nil {
		// Log the error using your preferred logging mechanism
		log.Printf("Error fetching registrations by leader: %v", err)
		return nil, errors.New("failed to fetch registrations by leader")
	}

	return registrations, nil
}

// CallRoom is the resolver for the CallRoom field.
func (r *queryResolver) CallRoom(ctx context.Context, subChurchID string) ([]*model.Registration, error) {
	var registrations []*model.Registration

	// Preload the Leader and member associations
	// Preload the Leader and member associations
	if err := r.DB.Where("sub_church_id = ?", subChurchID).Preload("Leader").Preload("Member.SubChurch").Order("created_at DESC").Find(&registrations).Error; err != nil {
		fmt.Println("Error preloading associations:", err)
		return nil, err
	}

	return registrations, nil
}

// GetAllRegistersByTempLeader is the resolver for the GetAllRegistersByTempLeader field.
func (r *queryResolver) GetAllRegistersByTempLeader(ctx context.Context, tempLeaderID string) ([]*model.Registration, error) {
	var Registrations []*model.Registration
	if err := r.DB.Where("temp_leader_id = ?", tempLeaderID).
		Preload("Member").
		Order("created_at DESC").
		Find(&Registrations).Error; err != nil {
		return nil, err
	}
	return Registrations, nil
}

// CurrentWeekRegistrations is the resolver for the currentWeekRegistrations field.
func (r *queryResolver) CurrentWeekRegistrations(ctx context.Context) ([]*model.Registration, error) {
	var registrations []*model.Registration
	if err := r.DB.Preload("Member").Order("created_at DESC").Find(&registrations).Error; err != nil {
		return nil, err
	}

	currentWeekNumber := schemas.GetWeekNumber(time.Now()) // Get the current week number

	// Fetch LeaderNames based on LeaderIDs or set to "No Assign Caller" if LeaderID is nil
	for _, reg := range registrations {
		MStext := "No Assign Caller"
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			if reg.LeaderID != nil {
				leaderMember := &model.Member{} // Assuming Leader is also a Member
				if err := r.DB.Where("id = ?", *reg.LeaderID).First(leaderMember).Error; err == nil {
					reg.LeaderName = &leaderMember.Name // Assuming you have a Name field in the Member model
				}
			} else {
				// Set LeaderName to "No Assign Caller" when LeaderID is nil
				reg.LeaderName = &MStext
			}
		}
	}

	var currentWeekRegistrations []*model.Registration
	for _, reg := range registrations {
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			currentWeekRegistrations = append(currentWeekRegistrations, reg)
		}
	}

	return currentWeekRegistrations, nil
}

// CurrentWeekRegistrationsforsub is the resolver for the currentWeekRegistrationsforsub field.
func (r *queryResolver) CurrentWeekRegistrationsforsub(ctx context.Context, subChurchID string) ([]*model.Registration, error) {
	var registrations []*model.Registration

	if err := r.DB.Preload("Member").Where("sub_church_id = ?", subChurchID).Order("created_at DESC").Find(&registrations).Error; err != nil {
		return nil, err
	}
	currentWeekNumber := schemas.GetWeekNumber(time.Now()) // Get the current week number

	// Fetch LeaderNames based on LeaderIDs or set to "No Assign Caller" if LeaderID is nil
	for _, reg := range registrations {
		MStext := "Not Called"
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			if reg.LeaderID != nil {
				leaderMember := &model.Member{} // Assuming Leader is also a Member
				if err := r.DB.Where("id = ?", *reg.LeaderID).First(leaderMember).Error; err == nil {
					reg.LeaderName = &leaderMember.Name // Assuming you have a Name field in the Member model
				}
			} else {
				// Set LeaderName to "No Assign Caller" when LeaderID is nil
				reg.LeaderName = &MStext
			}
		}
	}

	var currentWeekRegistrations []*model.Registration
	for _, reg := range registrations {
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			currentWeekRegistrations = append(currentWeekRegistrations, reg)
		}
	}

	return currentWeekRegistrations, nil
}

// CurrentWeekRegistrationsforCallCenter is the resolver for the currentWeekRegistrationsforCallCenter field.
func (r *queryResolver) CurrentWeekRegistrationsforCallCenter(ctx context.Context) ([]*model.SubChurch, error) {
	callCenterID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("leaderID not found in request context")
	}
	var subChurches []*model.SubChurch

	// Preload SubChurches, Members, and Registrations
	if err := r.DB.Preload("Members.Registrations").Where("call_center_id = ?", callCenterID).Order("created_at DESC").Find(&subChurches).Error; err != nil {
		return nil, err
	}

	// Filter SubChurches and Members based on current week registrations
	currentWeekNumber := schemas.GetWeekNumber(time.Now())
	for _, subChurch := range subChurches {
		subChurch.Members = schemas.FilterMembersByWeek(r.DB, ctx, subChurch.Members, currentWeekNumber)
	}

	return subChurches, nil
}

// WeekRegistrationsforSub is the resolver for the WeekRegistrationsforSub field.
func (r *queryResolver) WeekRegistrationsforSub(ctx context.Context) ([]*model.Registration, error) {
	// leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	// if !ok {
	// 	return nil, fmt.Errorf("leaderID not found in request context")
	// }
	var registrations []*model.Registration
	if err := r.DB.Preload("Member").Order("created_at DESC").Find(&registrations).Error; err != nil {
		return nil, err
	}
	currentWeekNumber := schemas.GetWeekNumber(time.Now()) // Get the current week number

	// Fetch LeaderNames based on LeaderIDs or set to "No Assign Caller" if LeaderID is nil
	for _, reg := range registrations {
		MStext := "No Assign Caller"
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			if reg.LeaderID != nil {
				leaderMember := &model.Member{} // Assuming Leader is also a Member
				if err := r.DB.Where("id = ?", *reg.LeaderID).First(leaderMember).Error; err == nil {
					reg.LeaderName = &leaderMember.Name // Assuming you have a Name field in the Member model
				}
			} else {
				// Set LeaderName to "No Assign Caller" when LeaderID is nil
				reg.LeaderName = &MStext
			}
		}
	}

	var currentWeekRegistrations []*model.Registration
	for _, reg := range registrations {
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			currentWeekRegistrations = append(currentWeekRegistrations, reg)
		}
	}

	return currentWeekRegistrations, nil
}

// ID is the resolver for the id field.
func (r *registrationResolver) ID(ctx context.Context, obj *model.Registration) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// ID is the resolver for the id field.
func (r *subChurchResolver) ID(ctx context.Context, obj *model.SubChurch) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// CallCenter returns CallCenterResolver implementation.
func (r *Resolver) CallCenter() CallCenterResolver { return &callCenterResolver{r} }

// Church returns ChurchResolver implementation.
func (r *Resolver) Church() ChurchResolver { return &churchResolver{r} }

// Member returns MemberResolver implementation.
func (r *Resolver) Member() MemberResolver { return &memberResolver{r} }

// MigrationRequest returns MigrationRequestResolver implementation.
func (r *Resolver) MigrationRequest() MigrationRequestResolver { return &migrationRequestResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Registration returns RegistrationResolver implementation.
func (r *Resolver) Registration() RegistrationResolver { return &registrationResolver{r} }

// SubChurch returns SubChurchResolver implementation.
func (r *Resolver) SubChurch() SubChurchResolver { return &subChurchResolver{r} }

type callCenterResolver struct{ *Resolver }
type churchResolver struct{ *Resolver }
type memberResolver struct{ *Resolver }
type migrationRequestResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type registrationResolver struct{ *Resolver }
type subChurchResolver struct{ *Resolver }
