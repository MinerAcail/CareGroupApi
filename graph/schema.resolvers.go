package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"log"
	"math/rand"
	"strings"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/kobbi/vbciapi/graph/model"
	"github.com/kobbi/vbciapi/graph/schemas"
	"github.com/kobbi/vbciapi/jwt/helpers"
	"github.com/kobbi/vbciapi/jwt/middleware"
	"github.com/kobbi/vbciapi/mypkg"
	"github.com/lib/pq"
	"github.com/tealeg/xlsx"
	"gorm.io/gorm"
)

// ID is the resolver for the id field.
func (r *churchResolver) ID(ctx context.Context, obj *model.Church) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// ID is the resolver for the id field.
func (r *memberResolver) ID(ctx context.Context, obj *model.Member) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// Types is the resolver for the types field.
func (r *memberResolver) Types(ctx context.Context, obj *model.Member) ([]string, error) {
	return obj.Types, nil
}

// ID is the resolver for the id field.
func (r *migrationRequestResolver) ID(ctx context.Context, obj *model.MigrationRequest) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// RequestSubChurchMigration is the resolver for the requestSubChurchMigration field.
func (r *mutationResolver) RequestSubChurchMigration(ctx context.Context, input model.SubChurchMigrationInput) (*model.MigrationRequest, error) {
	// You need to implement the logic to create a new migration request based on the input.

	// Check if the member exists based on input.memberId
	member, err := r.Query().Getmember(ctx, input.MemberID)
	if err != nil {
		return nil, fmt.Errorf("Member not found")
	}

	// Check if the destination sub-church exists based on input.destinationChurchId
	destinationChurch, err := r.Query().GetsubChurchByID(ctx, input.DestinationChurchID)
	if err != nil {
		return nil, fmt.Errorf(" Destination sub Church not found")
	}
	memberID := member.ID.String()
	destinationChurchID := destinationChurch.ID.String()

	PENDING := model.MigrationStatusPending

	// Create a new MigrationRequest record
	migrationRequest := &model.MigrationRequest{
		LocationFrom:        &member.SubChurch.Name,
		LocationEnd:         &destinationChurch.Name,
		MemberID:            &memberID,
		MemberName:          &member.Name,
		DestinationChurchID: destinationChurchID,
		Status:              &PENDING,
	}

	// Save the migration request to the database

	if err := r.DB.Create(migrationRequest).Error; err != nil {
		return nil, fmt.Errorf("failed to save to the database: %w", err)
	}

	// Return the created migration request
	return migrationRequest, nil
}

// ApproveSubChurchMigration is the resolver for the approveSubChurchMigration field.
func (r *mutationResolver) ApproveSubChurchMigration(ctx context.Context, requestID string) (*model.MigrationRequest, error) {
	// Check if the migration request exists based on requestID
	migrationRequest, err := r.Query().GetMigration(ctx, requestID)
	if err != nil {
		return nil, fmt.Errorf(" Migration request not found")
	}
	PENDING := model.MigrationStatusPending
	Approved := model.MigrationStatusApproved
	APPROVED := "APPROVED"
	REJECTED := "REJECTED"

	// Rejected := model.MigrationStatusRejected
	_ = model.MigrationStatusCompleted
	// fmt.Printf("migrationRequest value: %v\n",migrationRequest.Status)

	// Check if the current status is pending and update it to approved
	if PENDING != "PENDING" {
		return nil, fmt.Errorf(" Migration request is not in a pending state and cannot be approved")
	}
	if REJECTED == string(*migrationRequest.Status) {
		return nil, fmt.Errorf(" Migration request is already Rejected")
	}
	if APPROVED == string(*migrationRequest.Status) {
		return nil, fmt.Errorf(" Migration request is already Approved")
	}
	// Start a database transaction
	tx := r.DB.Begin()
	if tx.Error != nil {
		return nil, fmt.Errorf(" Failed to start a database transaction: %w", tx.Error)
	}
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback() // Rollback the transaction on any panics
		}
	}()

	// Create a WaitGroup to wait for both goroutines
	var wg sync.WaitGroup

	// Update the status to approved
	migrationRequest.Status = &Approved
	if err := tx.Save(migrationRequest).Error; err != nil {
		tx.Rollback()
		return nil, fmt.Errorf(" Failed to update migration request status: %w", err)
	}

	// Goroutine to update the member's data
	wg.Add(1)
	go func() {
		defer wg.Done()

		// Update the member's data
		Member := &model.Member{}
		// Retrieve the Member from the database based on the provided ID
		if err := r.DB.Where("id = ?", migrationRequest.MemberID).First(Member).Error; err != nil {
			tx.Rollback()
			return
		}

		// Modify the member's data as needed
		Member.SubChurchID = nil
		Member.LeaderID = nil
		Member.Types = nil
		Member.Password = nil
		Member.Token = nil
		Member.ReferenceIDCount = nil
		Member.SubChurchID = &migrationRequest.DestinationChurchID

		// Save the updated Member data
		if err := tx.Save(Member).Error; err != nil {
			tx.Rollback()
		}
	}()

	// Goroutine to delete all the registrations associated with the member
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := tx.Where("member_id = ?", migrationRequest.MemberID).Delete(&model.Registration{}).Error; err != nil {
			tx.Rollback()
		}
	}()

	// Wait for both goroutines to finish
	wg.Wait()

	// Commit the transaction if all updates and deletions are successful
	if err := tx.Commit().Error; err != nil {
		return nil, fmt.Errorf(" Failed to commit the transaction: %w", err)
	}

	// Return the updated migration request
	return migrationRequest, nil
}

// RejectSubChurchMigration is the resolver for the rejectSubChurchMigration field.
func (r *mutationResolver) RejectSubChurchMigration(ctx context.Context, requestID string) (*model.MigrationRequest, error) {
	// Check if the migration request exists based on requestID
	migrationRequest, err := schemas.GetMigrationRequestByID(r.DB, requestID)
	if err != nil {
		return nil, fmt.Errorf(" Migration request not found")
	}
	// Approved := model.MigrationStatusApproved
	Rejected := model.MigrationStatusRejected
	APPROVED := "APPROVED"
	REJECTED := "REJECTED"

	// // Check if the current status is pending and update it to rejected
	if APPROVED == string(*migrationRequest.Status) {
		return nil, fmt.Errorf(" The migration request has already been approved and is not in a pending state, so it cannot be rejected")
	}

	if REJECTED == string(*migrationRequest.Status) {
		return nil, fmt.Errorf(" The migration request has already been marked as rejected and cannot be rejected again")
	}

	// // Update the status to rejected
	migrationRequest.Status = &Rejected

	// Start a database transaction
	tx := r.DB.Begin()
	if tx.Error != nil {
		return nil, fmt.Errorf(" Failed to start a database transaction: %w", tx.Error)
	}
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback() // Rollback the transaction on any panics
		}
	}()

	// Save the updated migration request to the database within the transaction
	if err := tx.Save(migrationRequest).Error; err != nil {
		tx.Rollback() // Rollback the transaction on error
		return nil, fmt.Errorf(" Failed to update the migration request: %w", err)
	}

	// If the status is rejected, delete the migration request from the database
	if migrationRequest.Status == &Rejected {
		// Sleep for 1 minute before deleting
		// time.Sleep(1 * time.Minute)
		if err := tx.Delete(migrationRequest).Error; err != nil {
			tx.Rollback() // Rollback the transaction on error
			return nil, fmt.Errorf(" Failed to delete the migration request: %w", err)
		}
	}

	// Commit the transaction if all updates are successful
	if err := tx.Commit().Error; err != nil {
		return nil, fmt.Errorf(" Failed to commit the transaction: %w", err)
	}

	// Return the updated (or deleted) migration request
	return migrationRequest, nil
}

// GetMyL is the resolver for the getMyL field.
func (r *mutationResolver) GetMyL(ctx context.Context, id *string) (*model.MyType, error) {
	// myArray := mypkg.Myarray{"item1", "item2", "item3"}
	myArray := pq.StringArray{"item1", "item2", "item3"}

	myType := &model.MyType{
		MyArray: mypkg.Myarray(myArray),
	}

	if err := r.DB.Create(myType).Error; err != nil {
		return nil, fmt.Errorf("failed to save to the database: %w", err)
	}
	return myType, nil
}

// PushMyL is the resolver for the PushMyL field.
func (r *mutationResolver) PushMyL(ctx context.Context, id *string, newValue string) (*model.MyType, error) {
	// Find the MyType object with the given ID
	existingMyType := &model.MyType{}

	// Retrieve the Member from the database based on the provided ID
	if err := r.DB.Where("id = ?", id).First(existingMyType).Error; err != nil {
		return nil, fmt.Errorf("failed to find MyType: %w", err)
	}
	myArray := mypkg.Myarray{newValue}

	// Append the new value to the existing array
	existingMyType.MyArray = append(existingMyType.MyArray, myArray...)

	// Use GORM's Save method to update the MyType object in the database
	if err := r.DB.Save(existingMyType).Error; err != nil {
		return nil, fmt.Errorf("failed to save to the database: %w", err)
	}

	return existingMyType, nil
}

// GetMyArr is the resolver for the getMyArr field.
func (r *mutationResolver) GetMyArr(ctx context.Context) (*model.MyArr, error) {
	panic(fmt.Errorf("not implemented: GetMyArr - getMyArr"))
}

// CreateMember is the resolver for the createMember field.
func (r *mutationResolver) CreateMember(ctx context.Context, input *model.CreateMemberInput) (*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}

	// Check if email already exists
	members := &model.Member{}
	// Call the checking Duplicate Records function if already in db
	if err := schemas.CheckDuplicateRecords(r.DB, members, input.Name, input.Email, *input.PhoneNumber); err != nil {
		return nil, err
	}

	// Find the leader for the new member's day using FindLeaderWithSameDay
	leader, err := schemas.FindLeaderWithSameDay(ctx, r.DB, input.Day, input.ChurchID)
	if err != nil {
		return nil, fmt.Errorf("failed to create member : ")
	}
	// Convert leader .ID to a string before assigning it to LeaderID
	leaderID := leader.ID.String()
	PhoneNumber := schemas.CleanPhoneNumber(*input.PhoneNumber)

	member := &model.Member{
		Name:        input.Name,
		Email:       input.Email,
		PhoneNumber: &PhoneNumber,
		Day:         input.Day,
		Location:    input.Location,
		SubChurchID: &input.ChurchID,
		LeaderID:    &leaderID, // Assign the LeaderID to the selected leader's ID
	}

	// Save the member to the database using your preferred ORM-
	if err := r.DB.Create(member).Error; err != nil {
		return nil, fmt.Errorf("failed to save member to the database: %w", schemas.ErrDatabase)
	}
	// Call UpdateReferenceIDCounts to ensure the counts are up-to-date.
	if err := schemas.UpdateReferenceIDCounts(r.DB, input.ChurchID); err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}
	return member, nil
}

// CreateMemberbySubchurch is the resolver for the createMemberbySubchurch field.
func (r *mutationResolver) CreateMemberbySubchurch(ctx context.Context, input *model.CreateMemberInput) (*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	subChurchID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("leaderID not found in request context")
	}
	// Check if email already exists
	members := &model.Member{}
	// Call the checking Duplicate Records function if already in db
	if err := schemas.CheckDuplicateRecords(r.DB, members, input.Name, input.Email, *input.PhoneNumber); err != nil {
		return nil, err
	}
	var leaders []model.Member

	// if err := r.DB.Where("types IN (?) AND sub_church_id = ?", pq.Array([]string{"Leader", "SubLeader"}), churchID).Find(&leaders).Error; err != nil {
	// 	fmt.Println("Database error:", err)
	// 	return nil, err
	// }
	if err := r.DB.Where("sub_church_id = ? AND types && ?", subChurchID, pq.Array([]string{"Leader", "SubLeader"})).Find(&leaders).Error; err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}

	var lop *model.Member
	if len(leaders) == 1 {
		// // Get the leader for the given churchID
		leader, err := schemas.GetLeaderByChurchID(r.DB, &subChurchID)
		if err != nil {
			return nil, err
		}
		lop = leader

	} else if len(leaders) > 1 {

		// // Get the leader for the given churchID
		leader, err := schemas.FindLeaderWithSameDay(ctx, r.DB, input.Day, subChurchID)
		if err != nil {
			return nil, err
		}
		lop = leader
	}

	leaderID := lop.ID.String()
	// Find the leader for the new member's day using FindLeaderWithSameDay

	// Convert leader .ID to a string before assigning it to LeaderID
	// leaderID := leader.ID.String()
	PhoneNumber := schemas.CleanPhoneNumber(*input.PhoneNumber)

	member := &model.Member{
		Name:        input.Name,
		Email:       input.Email,
		PhoneNumber: &PhoneNumber,
		Day:         input.Day,
		Location:    input.Location,
		SubChurchID: &subChurchID,
		LeaderID:    &leaderID, // Assign the LeaderID to the selected leader's ID
	}

	// Save the member to the database using your preferred ORM-
	if err := r.DB.Create(member).Error; err != nil {
		return nil, fmt.Errorf("failed to save member to the database: %w", schemas.ErrDatabase)
	}
	// Call UpdateReferenceIDCounts to ensure the counts are up-to-date.
	if err := schemas.UpdateReferenceIDCounts(r.DB, input.ChurchID); err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}
	return member, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, tags []string) (*model.Post, error) {
	// Create a new Post
	post := model.Post{
		Tags: tags,
	}

	// Save the Post to the database using GORM
	if err := r.DB.Create(&post).Error; err != nil {
		return nil, err
	}

	return &post, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id *string, tags []string) (*model.Post, error) {
	// Find the post in the database by its ID
	var post model.Post
	if err := r.DB.Where("id = ?", id).First(&post).Error; err != nil {
		return nil, err
	}

	// Create a map to store the tags to remove for efficient lookup
	tagsToRemoveMap := make(map[string]bool)
	for _, tag := range tags {
		tagsToRemoveMap[tag] = true
	}

	// Filter the existing tags, keeping only those not in the tagsToRemoveMap
	var updatedTags []string
	for _, existingTag := range post.Tags {
		if !tagsToRemoveMap[existingTag] {
			updatedTags = append(updatedTags, existingTag)
		}
	}

	// Update the post's Tags field with the filtered tags
	post.Tags = updatedTags

	// Save the updated post back to the database
	if err := r.DB.Save(&post).Error; err != nil {
		return nil, err
	}

	return &post, nil
}

// ImportMemberData is the resolver for the importMemberData field.
func (r *mutationResolver) ImportMemberData(ctx context.Context, file graphql.Upload, churchID *string) ([]*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo4AdminOnly(ctx)
	if err != nil {
		return nil, err
	}

	// Create a buffer to read the data from the file
	buffer := new(bytes.Buffer)

	// Read the data from the file into the buffer
	_, err = io.Copy(buffer, file.File)
	if err != nil {
		return nil, err
	}

	// Convert the data in the buffer to a string
	fileDataString := buffer.String()

	// Open the uploaded Excel file
	xlFile, err := xlsx.OpenBinary([]byte(fileDataString)) // Open Excel file from binary data
	if err != nil {
		return nil, err
	}

	// Check if the header row exists and find column indices
	headerRow := xlFile.Sheets[0].Rows[0]                             // Assuming the header row is the first row
	nameIdx, emailIdx, phoneIdx, day, Locations := -1, -1, -1, -1, -1 // Initialize variables to store the column indices

	// Loop through the cells in the header row to find the column indices
	for colIdx, cell := range headerRow.Cells {
		switch cell.String() {
		case "Name":
			nameIdx = colIdx
		case "Email":
			emailIdx = colIdx
		case "Day":
			day = colIdx
		case "Location":
			Locations = colIdx
		case "Phone Number":
			phoneIdx = colIdx
		}

	}

	// Check if any of the required columns are missing
	if nameIdx == -1 || emailIdx == -1 || phoneIdx == -1 || day == -1 || Locations == -1 {
		return nil, fmt.Errorf(" One or more required columns are missing in the Excel file")
	}

	var leaders []model.Member

	// if err := r.DB.Where("types IN (?) AND sub_church_id = ?", pq.Array([]string{"Leader", "SubLeader"}), churchID).Find(&leaders).Error; err != nil {
	// 	fmt.Println("Database error:", err)
	// 	return nil, err
	// }
	if err := r.DB.Where("sub_church_id = ? AND types && ?", churchID, pq.Array([]string{"Leader", "SubLeader"})).Find(&leaders).Error; err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, fmt.Errorf("leader not found")
	}
	if len(leaders) >= 2 {
		var leadersMap = make(map[string]*model.Member)

		for _, leader := range leaders {
			leadersMap[leader.Day] = &leader
		}

		// Ensure that there is a leader for each day of the week (Monday to Sunday)
		for _, day := range []string{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"} {
			if leadersMap[day] == nil {
				return nil, fmt.Errorf(" No leader assigned for %s", day)
			}
		}
	}

	var duplicateRecords []string
	members := []*model.Member{}

	for _, sheet := range xlFile.Sheets {
		for rowIndex, row := range sheet.Rows {
			// Skip the header row
			if rowIndex == 0 {
				continue
			}

			// Extract data from rows and cells and create member objects
			name := row.Cells[nameIdx].String()
			email := row.Cells[emailIdx].String()
			Day := row.Cells[day].String()
			Locations := row.Cells[Locations].String()

			// Clean phone number
			phoneNumber := row.Cells[phoneIdx].String()
			phoneNumber = schemas.CleanPhoneNumber(phoneNumber)
			var lop *model.Member
			if len(leaders) == 1 {
				// // Get the leader for the given churchID
				leader, err := schemas.GetLeaderByChurchID(r.DB, churchID)
				if err != nil {
					return nil, err
				}
				lop = leader

			} else if len(leaders) > 1 {

				// // Get the leader for the given churchID
				leader, err := schemas.FindLeaderWithSameDay(ctx, r.DB, Day, *churchID)
				if err != nil {
					return nil, err
				}
				lop = leader
			}

			leaderID := lop.ID.String()

			if leaderID == "" {
				// Handle the case where lop is nil, e.g., return an error or take appropriate action.
				return nil, fmt.Errorf("leaderID is nil")
			}

			// leaderID := lop.ID.String()

			// // Call the checking Duplicate Records function if already in db
			if err := schemas.CheckMembersDuplicateRecords(r.DB, name, email, phoneNumber); err != nil {
				// Collect the record with duplicate data
				duplicateRecords = append(duplicateRecords, fmt.Sprintf("Row %d - Name: %s, Email: %s, Phone: %s", rowIndex, name, email, phoneNumber))

				// Skip creating this member and continue to the next iteration
				continue
			}

			// Create a member object
			member := &model.Member{
				Name:        name,
				Email:       email,
				PhoneNumber: &phoneNumber,
				Day:         Day,
				Location:    &Locations,
				LeaderID:    &leaderID, // Assign the LeaderID to the selected leader's ID
				SubChurchID: churchID,
			}

			members = append(members, member)
		}
	}
	// If there are duplicate records, return an error with the list of duplicates
	if len(duplicateRecords) > 0 {
		errMessage := "Duplicate records found:\n" + strings.Join(duplicateRecords, "\n")
		return nil, fmt.Errorf(errMessage)
	}
	// Save the created members to the database
	for _, member := range members {
		if err := r.DB.Create(member).Error; err != nil {
			return nil, err
		}
	}
	// Call UpdateReferenceIDCounts to ensure the counts are up-to-date.
	if err := schemas.UpdateReferenceIDCounts(r.DB, *churchID); err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}

	return members, nil
}

// DataMembers is the resolver for the dataMembers field.
func (r *mutationResolver) DataMembers(ctx context.Context) (*string, error) {
	// member := &model.Member{}
	targetDate := "11/2/2023"

	// Delete members created on the target date
	if err := r.DB.Where("DATE(created_at) = ?", targetDate).Delete(&model.Member{}).Error; err != nil {
		return nil, fmt.Errorf("failed to delete members: %w", err)
	}

	// Return the count of remaining members as a success message
	successMessage := fmt.Sprintf("Deleted members created on %s", targetDate)
	return &successMessage, nil
}

// CleanUpPhoneNumbers is the resolver for the cleanUpPhoneNumbers field.
func (r *mutationResolver) CleanUpPhoneNumbers(ctx context.Context) ([]*string, error) {
	// Retrieve all phone numbers from the database
	var phoneNumbers []string
	if err := r.DB.Model(&model.Member{}).Pluck("phone_number", &phoneNumbers).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve phone numbers: %w", err)
	}

	// Clean and update each phone number
	cleanedPhoneNumbers := make([]*string, 0, len(phoneNumbers))
	for _, phoneNumber := range phoneNumbers {
		cleanedPhoneNumber := schemas.CleanPhoneNumber(phoneNumber)

		// Update the cleaned phone number in the database
		if err := r.DB.Model(&model.Member{}).Where("phone_number = ?", phoneNumber).Update("phone_number", cleanedPhoneNumber).Error; err != nil {
			return nil, fmt.Errorf("failed to update phone number: %w", err)
		}

		// Append the cleaned phone number to the result list
		cleanedPhoneNumbers = append(cleanedPhoneNumbers, &cleanedPhoneNumber)
	}

	return cleanedPhoneNumbers, nil
}

// CreateMemberBysubLeader is the resolver for the createMemberBysubLeader field.
func (r *mutationResolver) CreateMemberBysubLeader(ctx context.Context, input *model.CreateMemberInputBySub) (*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("leaderID not found in request context")
	}
	// Query the leader
	leader := &model.Member{}
	if err := r.DB.Where("id = ?", leaderID).First(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to find leader: %w", err)
	}
	// Check if  email already exists
	members := &model.Member{}
	// Call the checking Duplicate Records function if already in db
	if err := schemas.CheckDuplicateRecords(r.DB, members, input.Name, input.Email, *input.PhoneNumber); err != nil {
		return nil, err
	}
	PhoneNumber := schemas.CleanPhoneNumber(*input.PhoneNumber)

	member := &model.Member{
		Name:        input.Name,
		Email:       input.Email,
		PhoneNumber: &PhoneNumber,
		Day:         input.Day,
		Location:    input.Location,
		SubChurchID: &leader.SubChurch.ChurchID,
	}
	// Save the member to the database using your preferred ORM
	if err := r.DB.Create(member).Error; err != nil {
		return nil, fmt.Errorf("failed to save member to the database: %w", schemas.ErrDatabase)
	}
	return member, nil
}

// UpdateMember is the resolver for the updateMember field.
func (r *mutationResolver) UpdateMember(ctx context.Context, input model.UpdateMemberInput, memberID string) (*model.Member, error) {
	// Extract LeaderID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}

	Member := &model.Member{}
	// Retrieve the Member from the database based on the provided ID
	if err := r.DB.Where("id = ?", memberID).First(Member).Error; err != nil {
		return nil, err
	}

	// Check if the provided email is already used by another member
	if input.Email != nil {
		if err := r.DB.Where("email = ?", *input.Email).Not("id = ?", memberID).First(&model.Member{}).Error; err == nil {
			return nil, fmt.Errorf("email already exists")
		}
	}

	// Clean and update the phone number if provided
	if input.PhoneNumber != nil {
		PhoneNumber := schemas.CleanPhoneNumber(*input.PhoneNumber)
		Member.PhoneNumber = &PhoneNumber
	}

	// Update the Member's fields with the input values if they are provided
	if input.Name != nil {
		Member.Name = *input.Name
	}
	if input.Email != nil {
		Member.Email = *input.Email
	}
	if input.Day != nil {
		Member.Day = *input.Day
	}
	if input.Location != nil {
		Member.Location = input.Location
	}

	// Save the Member to the database
	if err := r.DB.Save(Member).Error; err != nil {
		return nil, err
	}

	// Return the updated Member
	return Member, nil
}

// UpdateLeader is the resolver for the updateLeader field.
func (r *mutationResolver) UpdateLeader(ctx context.Context, input model.UpdateLeaderProfileInput, memberID string) (*model.Member, error) {
	leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("leaderID not found in request context")
	}
	// Check if the authenticated user is the same as the member being updated.
	if leaderID != memberID {
		return nil, fmt.Errorf("unauthorized: you can only update your own profile")
	}
	// Fetch the leader from the database using memberID.
	leader := &model.Member{}
	if err := r.DB.First(leader, "id = ?", leaderID).Error; err != nil {
		return nil, fmt.Errorf("leader not found: %w", err)
	}

	// Verify the provided password against the hashed password in the database
	if err := helpers.VerifyPassword(*leader.Password, *input.Oldpassword); err != nil {
		return nil, fmt.Errorf("incorrect password, Can't make changes without you old Password")
	}
	PhoneNumber := schemas.CleanPhoneNumber(*input.PhoneNumber)

	// Update the leader's profile with the provided input fields.
	if input.Name != nil {
		leader.Name = *input.Name
	}
	if input.Email != nil {
		leader.Email = *input.Email
	}
	if input.PhoneNumber != nil {
		leader.PhoneNumber = &PhoneNumber
	}

	if input.Password != nil {
		// Hash and update the password if a new password is provided.
		password, err := helpers.HashPassword(*input.Password)
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %w", err)
		}
		leader.Password = &password
	}

	if input.Location != nil {
		leader.Location = input.Location
	}

	// Save the updated leader to the database.
	if err := r.DB.Save(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to save updated leader: %w", err)
	}

	return leader, nil
}

// UpdatesubChurch is the resolver for the updatesubChurch field.
func (r *mutationResolver) UpdatesubChurch(ctx context.Context, input model.UpdateLeaderProfileInput, subChurchID string) (*model.SubChurch, error) {
	leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("sub Church ID not found in request context")
	}
	// Check if the authenticated user is the same as the member being updated.
	if leaderID != subChurchID {
		return nil, fmt.Errorf("unauthorized: you can only update your own profile")
	}
	// Fetch the leader from the database using memberID.
	leader := &model.SubChurch{}
	if err := r.DB.First(leader, "id = ?", leaderID).Error; err != nil {
		return nil, fmt.Errorf("leader not found: %w", err)
	}

	// Verify the provided password against the hashed password in the database
	if err := helpers.VerifyPassword(*leader.Password, *input.Oldpassword); err != nil {
		return nil, fmt.Errorf("incorrect password, Can't make changes without you old Password")
	}

	// Update the leader's profile with the provided input fields.
	if input.Name != nil {
		leader.Name = *input.Name
	}
	if input.Email != nil {
		leader.Email = input.Email
	}

	if input.Password != nil {
		// Hash and update the password if a new password is provided.
		password, err := helpers.HashPassword(*input.Password)
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %w", err)
		}
		leader.Password = &password
	}

	// Save the updated leader to the database.
	if err := r.DB.Save(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to save updated leader: %w", err)
	}

	return leader, nil
}

// CreateChurch is the resolver for the createChurch field.
func (r *mutationResolver) CreateChurch(ctx context.Context, name string, email string, password *string) (*model.Church, error) {
	// Check if an email already exists
	existingChurch := &model.Church{}
	err := r.DB.Where("email = ?", email).First(existingChurch).Error
	if err == nil {
		return nil, fmt.Errorf("email already exists")
	} else if !errors.Is(err, gorm.ErrRecordNotFound) {
		return nil, err
	}

	// Hash the password
	hpassword, err := helpers.HashPassword(*password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}
	Types := "Admin"

	// Create a new church record
	newChurch := &model.Church{
		Name:     name,
		Password: &hpassword,
		Email:    &email,
		Types:    &Types,
	}

	if err := r.DB.Create(newChurch).Error; err != nil {
		return nil, fmt.Errorf("failed to create church: %v", err)
	}

	// Generate a token
	token, err := helpers.GenerateToken(Types, newChurch.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %v", err)
	}
	newChurch.Token = &token

	return newChurch, nil
}

// DeleteChurch is the resolver for the deleteChurch field.
func (r *mutationResolver) DeleteChurch(ctx context.Context, mainChurchID string) (bool, error) {
	UUID, err := uuid.Parse(mainChurchID)
	if err != nil {
		return false, fmt.Errorf("invalid ID: %w", err)
	}

	church := &model.Church{}

	if err := r.DB.Where("id = ?", UUID).First(&church).Error; err != nil {
		return false, err
	}

	// Delete the church from the database
	if err := r.DB.Delete(church).Error; err != nil {
		return false, err
	}
	return true, nil
}

// DeleteMember is the resolver for the deleteMember field.
func (r *mutationResolver) DeleteMember(ctx context.Context, memberID string) (bool, error) {
	member := &model.Member{}

	if err := r.DB.Where("id = ?", memberID).First(&member).Error; err != nil {
		return false, err
	}

	// Delete the member from the database
	if err := r.DB.Delete(member).Error; err != nil {
		return false, err
	}
	return true, nil
}

// DeleteSubChurch is the resolver for the deleteSubChurch field.
func (r *mutationResolver) DeleteSubChurch(ctx context.Context, subChurchID string) (bool, error) {
	subChurch := &model.SubChurch{}

	if err := r.DB.Where("id = ?", subChurchID).First(&subChurch).Error; err != nil {
		return false, err
	}

	// Delete the subChurch from the database
	if err := r.DB.Delete(subChurch).Error; err != nil {
		return false, err
	}
	return true, nil
}

// DeleteRegistration is the resolver for the deleteRegistration field.
func (r *mutationResolver) DeleteRegistration(ctx context.Context, registrationID string) (bool, error) {
	// // Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	// err := middleware.ExtractCTXinfo(ctx)
	// if err != nil {
	// 	return false, err
	// }
	UUID, err := uuid.Parse(registrationID)
	if err != nil {
		return false, fmt.Errorf("invalid leaderID: %w", err)
	}

	registration := &model.Registration{}

	if err := r.DB.Where("id = ?", UUID).First(&registration).Error; err != nil {
		return false, err
	}

	// Delete the registration from the database
	if err := r.DB.Delete(registration).Error; err != nil {
		return false, err
	}
	return true, nil
}

// CreateSubChurch is the resolver for the createSubChurch field.
func (r *mutationResolver) CreateSubChurch(ctx context.Context, subChurchName *string, branch bool) (*model.Church, error) {
	mainChurchID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("main ChurchID not found in request context")
	}
	// Convert subChurchName to uppercase
	uppercasedSubChurchName := ""
	if subChurchName != nil {
		uppercasedSubChurchName = strings.ToUpper(*subChurchName)
	}
	mainChurch := &model.Church{}

	// Find the main church by ID failed to find main church
	var church model.Church
	if err := r.DB.First(&church, "id = ?", mainChurchID).Error; err != nil {
		return nil, fmt.Errorf("failed to find main church in subChurch: %w", err)

	}

	// Check if the sub-church already exists
	if err := r.DB.Where("name = ? AND church_id = ?", uppercasedSubChurchName, mainChurchID).First(&model.SubChurch{}).Error; err == nil {
		return nil, fmt.Errorf("sub-church with the same name already exists")
	}

	Types := "subChurch"

	randomPassword := helpers.GenerateRandomPassword(6)
	// Hash the password
	hpassword, err := helpers.HashPassword(randomPassword)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}
	randomEmail := helpers.GenerateRandomEmail("envcare.com", randomPassword)
	// Create the sub-church and associate it with the main church
	subChurch := &model.SubChurch{
		Name:     uppercasedSubChurchName,
		ChurchID: mainChurchID,
		Email:    &randomEmail,
		Password: &hpassword,
		Types:    &Types,
	}

	if err := r.DB.Create(subChurch).Error; err != nil {
		return nil, fmt.Errorf("failed to create sub-church: %w", err)
	}

	// Generate a token
	token, err := helpers.GenerateToken(Types, subChurch.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %v", err)
	}
	subChurch.Token = &token
	// Append the sub-church to the main church's SubChurches slice
	mainChurch.SubChurches = append(mainChurch.SubChurches, subChurch)

	leadertype := []string{"Leader"}
	leaderpassword := "pass"
	leaderemail := "leader@gmail.com"

	// Generate random phone numbers
	randomPhoneNumber := func() string {
		return fmt.Sprintf("05%02d%03d", rand.Intn(100), rand.Intn(1000))
	}

	password, err := helpers.HashPassword(leaderpassword)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	subChurchIDStr := subChurch.ID.String() // Convert subChurch.ID to a string
	phoneNumber := randomPhoneNumber()      // Generate a random phone number for the leader

	leader := &model.Member{
		Name:  fmt.Sprintf("%s Leader", uppercasedSubChurchName),
		Email: leaderemail,

		Types:       leadertype,
		PhoneNumber: &phoneNumber,
		Password:    &password, // Set the leader's password here
		Day:         "none",
		SubChurchID: &subChurchIDStr,
		// Set other leader properties as needed
	}

	if err := r.DB.Create(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to create leader: %w", err)
	}

	token, err = helpers.GenerateToken(leadertype[0], (leader.ID.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to generate tokens: %w", err)
	}

	leader.Token = &token // Set the leader's token here

	return mainChurch, nil
}

// CreateMianChurch is the resolver for the createMianChurch field.
func (r *mutationResolver) CreateMianChurch(ctx context.Context, subChurchName *string) (*model.Church, error) {
	mainChurchID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("main ChurchID not found in request context")
	}
	// Convert subChurchName to uppercase
	uppercasedSubChurchName := ""
	if subChurchName != nil {
		uppercasedSubChurchName = strings.ToUpper(*subChurchName)
	}
	mainChurch := &model.Church{}

	if err := r.DB.First(mainChurch, "id = ?", mainChurchID).Error; err != nil {
		return nil, fmt.Errorf("failed to find main church: %w", err)
	}

	// Check if the sub-church already exists
	if err := r.DB.Where("name = ? AND church_id = ?", uppercasedSubChurchName, mainChurchID).First(&model.SubChurch{}).Error; err == nil {
		return nil, fmt.Errorf("sub-church with the same name already exists")
	}

	Types := "subChurch"

	randomPassword := helpers.GenerateRandomPassword(6)
	// Hash the password
	hpassword, err := helpers.HashPassword(randomPassword)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}
	randomEmail := helpers.GenerateRandomEmail("envcare.com", randomPassword)
	// Create the sub-church and associate it with the main church
	subChurch := &model.SubChurch{
		Name:     uppercasedSubChurchName,
		ChurchID: mainChurchID,
		Email:    &randomEmail,
		Password: &hpassword,
		Types:    &Types,
	}

	if err := r.DB.Create(subChurch).Error; err != nil {
		return nil, fmt.Errorf("failed to create sub-church: %w", err)
	}

	// Generate a token
	token, err := helpers.GenerateToken(Types, subChurch.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %v", err)
	}
	subChurch.Token = &token
	// Append the sub-church to the main church's SubChurches slice
	mainChurch.SubChurches = append(mainChurch.SubChurches, subChurch)
	// Define the days of the week
	leaderDaysOfWeek := []string{"Monday", "Tuesday", "Wednesday"}
	subLeaderDaysOfWeek := []string{"Thursday", "Friday", "Saturday", "Sunday"}
	// Create 3 leaders
	leaderIndex := 0
	leadertype := "Leader"
	leaderpassword := "pass"
	leaderemail := "leader@gmail.com"

	// Generate random phone numbers
	randomPhoneNumber := func() string {
		return fmt.Sprintf("05%02d%03d", rand.Intn(100), rand.Intn(1000))
	}

	password, err := helpers.HashPassword(leaderpassword)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", schemas.ErrInvalidInput)
	}

	for i := 0; i < 3; i++ {
		subChurchIDStr := subChurch.ID.String() // Convert subChurch.ID to a string
		phoneNumber := randomPhoneNumber()      // Generate random phone number for leaders

		leader := &model.Member{
			Name:  fmt.Sprintf("%s Leader %d", uppercasedSubChurchName, i+1),
			Email: leaderemail,
			Types: []string{leadertype},
			// Types:       &leadertype,
			PhoneNumber: &phoneNumber,
			Password:    &password, // Set the leader's password here
			Day:         leaderDaysOfWeek[leaderIndex],
			SubChurchID: &subChurchIDStr,
			// Set other leader properties as needed
		}

		if err := r.DB.Create(leader).Error; err != nil {
			return nil, fmt.Errorf("failed to create leader: %w", err)
		}

		leaderIndex = (leaderIndex + 1) % len(leaderDaysOfWeek) // Rotate through days of the week
		token, err := helpers.GenerateToken(leadertype, (leader.ID.String()))
		if err != nil {
			return nil, fmt.Errorf("failed to generate tokens: %w", err)
		}

		leader.Token = &token // Set the leader's token here
	}
	// Create 4 sub-leaders
	subLeaderIndex := 0
	subLeaderSubLeader := "SubLeader"
	for i := 0; i < 4; i++ {
		subChurchIDStr := subChurch.ID.String() // Convert subChurch.ID to a string
		phoneNumber := randomPhoneNumber()      // Generate random phone number for leaders

		subLeader := &model.Member{
			Name:  fmt.Sprintf("%s SubLeader %d", uppercasedSubChurchName, i+1),
			Types: []string{subLeaderSubLeader},

			// Types:       &subLeaderSubLeader,
			PhoneNumber: &phoneNumber,
			Password:    &password, // Set the sub-leader's password here
			Email:       leaderemail,
			Day:         subLeaderDaysOfWeek[subLeaderIndex],
			SubChurchID: &subChurchIDStr,
			// Set other sub-leader properties as needed
		}

		if err := r.DB.Create(subLeader).Error; err != nil {
			return nil, fmt.Errorf("failed to create sub-leader: %w", err)
		}

		subLeaderIndex = (subLeaderIndex + 1) % len(subLeaderDaysOfWeek) // Rotate through days of the week
		token, err := helpers.GenerateToken(leadertype, (subLeader.ID.String()))
		if err != nil {
			return nil, fmt.Errorf("failed to generate tokens: %w", err)
		}

		subLeader.Token = &token // Set the leader's token here
	}

	return mainChurch, nil
}

// klllllllllllleader is the resolver for the assignLeader field.
func (r *mutationResolver) AssignLeader(ctx context.Context, input *model.AssignLeaderInput) (*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	// Fetch the member by ID from the database.
	member := &model.Member{}
	if err := r.DB.First(member, "id = ?", input.MemberID).Error; err != nil {
		return nil, err // Handle the error if the member is not found.
	}

	// Check if the input type already exists in member.Types.
	for _, existingType := range member.Types {
		if existingType == *input.Types {
			return nil, fmt.Errorf("member already has the '%s' type", *input.Types)
		}
	}

	// Validate the input.Types field.
	if input.Types != nil && (*input.Types == "Admin") {
		return nil, fmt.Errorf("cannot assign Admin role") // Return an error if the input.Types is "Admin."
	}
	// Validate the input.Types field.
	if input.Types != nil && (*input.Types != "SubLeader" && *input.Types != "CallAgent" && *input.Types != "Leader") {
		return nil, fmt.Errorf("invalid leadership role: %s", *input.Types)
	}

	if member.Password == nil {
		// Hash the input password if a password does not exist.
		password, err := helpers.HashPassword(*input.Password)
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %w", schemas.ErrInvalidInput)
		}
		member.Password = &password
	}

	// member.Types = input.Types
	member.Types = append(member.Types, *input.Types)
	// member.Types = input.Types

	token, err := helpers.GenerateToken(*input.Types, (member.ID.String()))
	if err != nil {
		return nil, fmt.Errorf("failed to generate tokens: %w", err)
	}
	member.Token = &token

	// Save the updated member to the database.
	if err := r.DB.Save(member).Error; err != nil {
		return nil, err // Handle the error if there's an issue saving the member.
	}

	return member, nil
}

// AddAnotherType is the resolver for the addAnotherType field.
func (r *mutationResolver) AddAnotherType(ctx context.Context, memberID string, types *string) (*model.Member, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}

	// Fetch the member by ID from the database.
	member := &model.Member{}
	if err := r.DB.First(member, "id = ?", memberID).Error; err != nil {
		return nil, err // Handle the error if the member is not found.
	}

	// Validate the types field.
	if types == nil {
		return nil, fmt.Errorf("types cannot be empty")
	}

	// Check if the specified type is valid.
	if *types == "Admin" {
		return nil, fmt.Errorf("cannot assign Admin role")
	}

	// Check if the specified type is one of the valid leadership roles.
	validRoles := []string{"SubLeader", "CallAgent", "Leader"}
	isValidRole := false
	for _, role := range validRoles {
		if *types == role {
			isValidRole = true
			break
		}
	}
	if !isValidRole {
		return nil, fmt.Errorf("invalid leadership role: %s", *types)
	}

	// You can add additional logic to update the member's roles based on the new types.
	// For example, append the new type to the existing roles.
	member.Types = append(member.Types, *types)
	// member.Types = types

	// Save the updated member to the database.
	if err := r.DB.Save(member).Error; err != nil {
		return nil, err // Handle the error if there's an issue saving the member.
	}

	return member, nil
}

// UpdateLeaderTypes is the resolver for the updateLeaderTypes field.
func (r *mutationResolver) UpdateLeaderTypes(ctx context.Context, id *string, tags []string) (*model.Member, error) {
	// Find the post in the database by its ID
	var Member model.Member
	if err := r.DB.Where("id = ?", id).First(&Member).Error; err != nil {
		return nil, err
	}

	// Create a map to store the tags to remove for efficient lookup
	tagsToRemoveMap := make(map[string]bool)
	for _, tag := range tags {
		tagsToRemoveMap[tag] = true
	}

	// Filter the existing tags, keeping only those not in the tagsToRemoveMap
	var updatedTags []string
	for _, existingTag := range Member.Types {
		if !tagsToRemoveMap[existingTag] {
			updatedTags = append(updatedTags, existingTag)
		}
	}

	// Update the Member's Tags field with the filtered tags
	Member.Types = updatedTags

	// Save the updated Member back to the database
	if err := r.DB.Save(&Member).Error; err != nil {
		return nil, err
	}

	return &Member, nil
}

// RemoveLeader is the resolver for the removeLeader field.
func (r *mutationResolver) RemoveLeader(ctx context.Context, memberID string) (*model.Member, error) {
	// Fetch the member by ID from the database.
	member := &model.Member{}
	if err := r.DB.First(member, "id = ?", memberID).Error; err != nil {
		return nil, err // Handle the error if the member is not found.
	}

	// Check if the member is currently assigned as a leader.
	if member.Types != nil {
		// If the member is a leader, remove the leadership role.
		member.Types = nil
		member.Token = nil    // Optionally, clear the token to invalidate it.
		member.Password = nil // Optionally, clear the password to invalidate it.

		// Save the updated member to the database.
		if err := r.DB.Save(member).Error; err != nil {
			return nil, err // Handle the error if there's an issue saving the member.
		}

		return member, nil
	}

	return nil, fmt.Errorf("member is not currently assigned as a leader")
}

// CreateSubChurchesWithMainChurch is the resolver for the createSubChurchesWithMainChurch field.
func (r *mutationResolver) CreateSubChurchesWithMainChurch(ctx context.Context, mainChurchID string, subChurchNames []string) (*model.Church, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}

	// leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	// if !ok {
	// 	return nil, fmt.Errorf("leaderID not found in request context")
	// }

	// Find the main church by ID
	mainChurch := &model.Church{}
	if err := r.DB.First(mainChurch, "id = ?", mainChurchID).Error; err != nil {
		return nil, fmt.Errorf("failed to find main church: %w", err)
	}

	// Create sub-churches and associate them with the main church
	subChurches := make([]model.SubChurch, len(subChurchNames))
	for i, subChurchName := range subChurchNames {
		subChurches[i] = model.SubChurch{
			Name:     subChurchName,
			ChurchID: mainChurchID,
		}
	}
	if err := r.DB.Create(&subChurches).Error; err != nil {
		return nil, fmt.Errorf("failed to create sub-churches: %w", err)
	}

	return mainChurch, nil
}

// CreateRegistration is the resolver for the createRegistration field.
func (r *mutationResolver) CreateRegistration(ctx context.Context, memberID string, input model.CreateRegistrationInput) (*model.Registration, error) {
	// Check if memberID is a valid UUID
	_, err := uuid.Parse(memberID)
	if err != nil {
		return nil, fmt.Errorf("invalid memberID: %w", err)
	}

	// Query the database to check for existing registrations within the past 24 hours
	var lastRegistrationTime time.Time
	if err := r.DB.Model(&model.Registration{}).
		Select("created_at").
		Where("member_id = ?", memberID).
		Order("created_at DESC").
		First(&lastRegistrationTime).
		Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		return nil, err
	}

	// Calculate the time difference between now and the last registration
	timeSinceLastRegistration := time.Since(lastRegistrationTime)

	// Define the rate limit (24 hours)
	rateLimit := 24 * time.Hour

	// Check if the last registration was within the rate limit
	if timeSinceLastRegistration < rateLimit {
		return nil, fmt.Errorf("rate limit exceeded, you can create a registration again in %v", rateLimit-timeSinceLastRegistration)
	}

	// Create a new Registration object using the input data
	registration := &model.Registration{
		MemberID: memberID,
	}
	if input.LastComment != nil {
		registration.LastComment = *input.LastComment
	}

	if input.Absence != nil {
		registration.Absence = *input.Absence
	}

	if input.Present != nil {
		registration.Present = *input.Present
	}

	// Save the registration to the database
	if err := r.DB.Create(registration).Error; err != nil {
		return nil, err
	}

	// Return the created registration
	return registration, nil
}

// CreateRegistrationArray is the resolver for the createRegistrationArray field.
func (r *mutationResolver) CreateRegistrationArray(ctx context.Context, input []*model.RegistrationArrayInput) ([]*model.Registration, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	if !ok {
		return nil, fmt.Errorf("leaderID not found in request context")
	}
	// Retrieve the SubChurchID associated with the leaderID
	subChurchID, err := schemas.GetSubChurchIDForLeader(r.DB, leaderID)
	if err != nil {
		return nil, err
	}
	createdRegistrations := []*model.Registration{}
	exceededRateLimitMembers := []string{} // Track members who exceeded the rate limit of 24 hours a  Leader can't create a register within 24 hours

	for _, registrationInput := range input {
		// Check if MemberID is a valid UUID
		_, err := uuid.Parse(registrationInput.MemberID)
		if err != nil {
			return nil, fmt.Errorf("invalid MemberID: %w", err)
		}

		// Query the database to check if the member exists
		var member model.Member
		if err := r.DB.Model(&model.Member{}).
			Where("id = ?", registrationInput.MemberID).
			First(&member).
			Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, err
		}

		// Ensure that the member exists
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("member with ID %s does not exist", registrationInput.MemberID)
		}

		// Query the database to check for existing registrations within the past 24 hours
		var lastRegistrationTime time.Time
		if err := r.DB.Model(&model.Registration{}).
			Select("created_at").
			Where("member_id = ?", registrationInput.MemberID).
			Order("created_at DESC").
			First(&lastRegistrationTime).
			Error; err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, err
		}

		// Calculate the time difference between now and the last registration
		timeSinceLastRegistration := time.Since(lastRegistrationTime)

		// Define the rate limit (24 hours)
		rateLimit := 24 * time.Hour

		// Check if the last registration was within the rate limit
		if timeSinceLastRegistration < rateLimit {
			exceededRateLimitMembers = append(exceededRateLimitMembers, member.Name) // Track the name of the member
			continue                                                                 // Skip creating a registration for this member
		}

		// Create a new Registration object using the input data
		registration := &model.Registration{
			MemberID:    registrationInput.MemberID,
			SubChurchID: &subChurchID,
		}
		if registrationInput.CreateInput.LastComment != nil {
			registration.LastComment = *registrationInput.CreateInput.LastComment
		}

		if registrationInput.CreateInput.Absence != nil {
			registration.Absence = *registrationInput.CreateInput.Absence
		}

		if registrationInput.CreateInput.Present != nil {
			registration.Present = *registrationInput.CreateInput.Present
		}

		// Save the registration to the database
		if err := r.DB.Create(registration).Error; err != nil {
			return nil, err
		}

		createdRegistrations = append(createdRegistrations, registration)
	}

	// Check if any members exceeded the rate limit and include their names in the error message
	if len(exceededRateLimitMembers) > 0 {
		return nil, fmt.Errorf(" %v Cannot create registrations within the specified time frame", exceededRateLimitMembers)
	}

	// Return the created registrations
	return createdRegistrations, nil
}

// UpdateRegistration is the resolver for the updateRegistration field.
func (r *mutationResolver) UpdateRegistration(ctx context.Context, input model.CreateRegistrationInput, registrationID string) (*model.Registration, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	// Fetch the existing registration from the database
	uuid, err := uuid.Parse(registrationID)
	if err != nil {
		return nil, fmt.Errorf("invalid registrationID: %w", err)
	}
	registration := &model.Registration{}

	if err := r.DB.Where("id = ?", uuid).First(&registration).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("registration not found")
		}
		return nil, err
	}

	// Update the fields with the new values
	if input.Absence != nil {
		registration.Absence = *input.Absence
	}
	if input.Present != nil {
		registration.Present = *input.Present
	}
	if input.LastComment != nil {
		registration.LastComment = *input.LastComment
	}

	// Save the updated registration to the database
	if err := r.DB.Save(registration).Error; err != nil {
		return nil, err
	}

	// Convert the GORM model to the GraphQL model and return
	return registration, nil
}

// UpdateRegistrationByLeader is the resolver for the updateRegistrationByLeader field.
func (r *mutationResolver) UpdateRegistrationByLeader(ctx context.Context, input model.CreateRegistrationInput, registrationID string, leaderID string) (*model.Registration, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	// Validate registrationID and leaderID as valid UUIDs
	registrationUUID, err := uuid.Parse(registrationID)
	if err != nil {
		return nil, fmt.Errorf("invalid registrationID: %w", err)
	}

	_, err = uuid.Parse(leaderID)
	if err != nil {
		return nil, fmt.Errorf("invalid leaderID: %w", err)
	}

	// Fetch the registration from the database
	register := &model.Registration{}

	if err := r.DB.Where("id = ?", registrationUUID).First(&register).Error; err != nil {
		// Handle the case when the registration is not found
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("registration not found")
		}
		return nil, err
	}

	// Check if the registration is associated with the provided leader ID
	if register.LeaderID != nil && *register.LeaderID != leaderID {
		return nil, fmt.Errorf("registration is not associated with the provided leader")
	}

	// Update the registration's attributes based on the input
	if input.Absence != nil {
		if *input.Absence {
			// If Absence is set to true, set Present to false
			register.Present = false
		}
		register.Absence = *input.Absence
	}

	if input.Present != nil {
		if *input.Present {
			// If Present is set to true, set Absence to false
			register.Absence = false
		}
		register.Present = *input.Present
	}
	if input.LastComment != nil && *input.LastComment != "" {
		register.LastComment = *input.LastComment
	}

	// Save the updated registration
	if err := r.DB.Save(register).Error; err != nil {
		return nil, err
	}

	return register, nil
}

// DistributeRegistrationsToLeaders is the resolver for the distributeRegistrationsToLeaders field.
func (r *mutationResolver) DistributeRegistrationsToLeaders(ctx context.Context, leaderIds []string) ([]*model.LeaderRegistrationsDistribution, error) {
	// Extract Admin's ID from the request context (provided by AuthenticationMiddleware).
	err := middleware.ExtractCTXinfo(ctx)
	if err != nil {
		return nil, err
	}
	// Fetch the current week's registrations
	currentWeekRegistrations, err := r.Query().CurrentWeekRegistrations(ctx)
	if err != nil {
		return nil, err
	}

	// Shuffle the leader IDs using your shuffling algorithm
	schemas.ShuffleLeaders(leaderIds)

	// Create a map to store registration IDs for each leader
	leaderRegistrationMap := make(map[string][]string)

	// Distribute registration IDs among shuffled leader IDs
	for i, reg := range currentWeekRegistrations {
		leaderIndex := i % len(leaderIds)
		leaderID := leaderIds[leaderIndex]
		leaderRegistrationMap[leaderID] = append(leaderRegistrationMap[leaderID], reg.ID.String())

		// Convert leaderID (string) to uuid.UUID
		_, err := uuid.Parse(leaderID)
		if err != nil {
			return nil, err // Handle the error appropriately
		}

		// Update the registration's LeaderID with the converted uuid.UUID
		reg.LeaderID = &leaderID // Update this line
		if err := r.DB.Save(&reg).Error; err != nil {
			return nil, err
		}
	}

	// Create the final response structure
	var leaderDistribution []*model.LeaderRegistrationsDistribution
	for leaderID, regIDs := range leaderRegistrationMap {
		leaderDist := &model.LeaderRegistrationsDistribution{
			LeaderID:        leaderID,
			RegistrationIDs: regIDs,
		}
		leaderDistribution = append(leaderDistribution, leaderDist)
	}

	return leaderDistribution, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginLeaderInput) (model.Returns, error) {
	clear := model.RemoveSpacesFromNumber(*input.Email)
	if model.IsValidEmail(clear) {
		// Fetch the leader from the database based on the provided email
		leader := &model.Church{}
		sub := &model.SubChurch{}

		// Check if it's an admin leader
		if err := r.DB.Where("email = ?", clear).First(leader).Error; err == nil {
			if *leader.Types == "Admin" {
				// Verify the provided password against the hashed password in the database
				if err := helpers.VerifyPassword(*leader.Password, input.Password); err != nil {
					return nil, fmt.Errorf("invalid password")
				}
				// Generate a new token for the authenticated leader
				token, err := helpers.GenerateToken(*leader.Types, leader.ID.String())
				if err != nil {
					return nil, fmt.Errorf("failed to generate token")
				}
				// Update the leader's token with the newly generated token
				leader.Token = &token

				// Save the updated leader with the token to the database
				if err := r.DB.Save(leader).Error; err != nil {
					return nil, fmt.Errorf("failed to save leader's token to the database")
				}

				// Retrieve the CookieAccess object from the context
				ca := middleware.GetCookieAccess(ctx)

				// Set the generated token as a cookie using the CookieAccess object
				ca.SetToken(token)

				return leader, nil
			}
		} else if err := r.DB.Where("email = ?", clear).First(sub).Error; err == nil {
			if *sub.Types == "subChurch" {
				// Verify the provided password against the hashed password in the database
				if err := helpers.VerifyPassword(*sub.Password, input.Password); err != nil {
					return nil, fmt.Errorf("invalid password")
				}
				// Generate a new token for the authenticated sub
				token, err := helpers.GenerateToken(*sub.Types, sub.ID.String())
				if err != nil {
					return nil, fmt.Errorf("failed to generate token")
				}
				// Update the sub's token with the newly generated token
				sub.Token = &token

				// Save the updated sub with the token to the database
				if err := r.DB.Save(sub).Error; err != nil {
					return nil, fmt.Errorf("failed to save sub's token to the database")
				}

				// Retrieve the CookieAccess object from the context
				ca := middleware.GetCookieAccess(ctx)

				// Set the generated token as a cookie using the CookieAccess object
				ca.SetToken(token)

				return sub, nil
			}
		}
		return nil, fmt.Errorf("email not found or invalid login input")
	} else if model.IsNumeric(clear) {
		leader := &model.Member{}
		if err := r.DB.Where("phone_number = ?", clear).First(leader).Error; err != nil {
			return nil, fmt.Errorf("leader not found")
		}
		// Verify the provided password against the hashed password in the database
		if err := helpers.VerifyPassword(*leader.Password, input.Password); err != nil {
			return nil, fmt.Errorf("invalid password")
		}
		// Generate a new token for the authenticated leader
		token, err := helpers.GenerateToken(leader.Types[0], leader.ID.String())
		// token, err := helpers.GenerateToken(*leader.Types, leader.ID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to generate token")
		}
		// Update the leader's token with the newly generated token
		leader.Token = &token

		// Save the updated leader with the token to the database
		if err := r.DB.Save(leader).Error; err != nil {
			return nil, fmt.Errorf("failed to save leader's token to the database")
		}

		// Retrieve the CookieAccess object from the context
		ca := middleware.GetCookieAccess(ctx)

		// Set the generated token as a cookie using the CookieAccess object
		ca.SetToken(token)

		return leader, nil
	}
	return nil, fmt.Errorf("invalid login input")
}

// Memberlogin is the resolver for the memberlogin field.
func (r *mutationResolver) Memberlogin(ctx context.Context, input model.LoginLeaderInput) (model.Returns, error) {
	leader := &model.Member{}
	if err := r.DB.Where("phone_number = ?", input.Email).First(leader).Error; err != nil {
		return nil, fmt.Errorf("leader not found")
	}
	// Verify the provided password against the hashed password in the database
	if err := helpers.VerifyPassword(*leader.Password, input.Password); err != nil {
		return nil, fmt.Errorf("invalid password")
	}

	// Generate a new token for the authenticated leader
	token, err := helpers.GenerateToken(leader.Types[0], leader.ID.String())
	// token, err := helpers.GenerateToken(*leader.Types, leader.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}
	// Update the leader's token with the newly generated token
	leader.Token = &token

	// Save the updated leader with the token to the database
	if err := r.DB.Save(leader).Error; err != nil {
		return nil, fmt.Errorf("failed to save leader's token to the database")
	}

	// Retrieve the CookieAccess object from the context
	ca := middleware.GetCookieAccess(ctx)

	// Set the generated token as a cookie using the CookieAccess object
	ca.SetToken(token)

	return leader, nil
}

// LogOut is the resolver for the logOut field.
func (r *mutationResolver) LogOut(ctx context.Context) (bool, error) {
	// Assuming you have access to the CookieAccess object from the context
	cookieAccess := middleware.GetCookieAccess(ctx)

	// Call the Logout method to clear the user's session cookie
	err := cookieAccess.Logout()
	if err != nil {
		// Handle the error, e.g., log it or return an appropriate GraphQL error
		return false, err
	}

	// You can also perform any other logout-related actions here,
	// such as invalidating tokens, revoking access, etc.

	// Return true to indicate a successful logout
	return true, nil
}

// ID is the resolver for the ID field.
func (r *myArrResolver) ID(ctx context.Context, obj *model.MyArr) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// ID is the resolver for the ID field.
func (r *myTypeResolver) ID(ctx context.Context, obj *model.MyType) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// ID is the resolver for the id field.
func (r *postResolver) ID(ctx context.Context, obj *model.Post) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// Tags is the resolver for the tags field.
func (r *postResolver) Tags(ctx context.Context, obj *model.Post) ([]string, error) {
	return obj.Tags, nil
}

// GetAllMainChurch is the resolver for the GetAllMainChurch field.
func (r *queryResolver) GetAllMainChurch(ctx context.Context) ([]*model.Church, error) {
	var churchs []*model.Church
	if err := r.DB.Find(&churchs).Order("created_at DESC").Error; err != nil {
		return nil, err
	}

	return churchs, nil
}

// GetsubChurchByMainChurchID is the resolver for the GetsubChurchByMainChurchID field.
func (r *queryResolver) GetAllsubChurchByMainChurchID(ctx context.Context, mainChurchID string) ([]*model.SubChurch, error) {
	var subChurch []*model.SubChurch
	if err := r.DB.Where("church_id = ?", mainChurchID).Preload("Church").Order("created_at DESC").Find(&subChurch).Error; err != nil {
		return nil, err
	}

	return subChurch, nil
}

// GetAllsubChurchByMemberID is the resolver for the GetAllsubChurchByMemberId field.
func (r *queryResolver) GetAllsubChurchByMemberID(ctx context.Context, memberID string) ([]*model.SubChurch, error) {
	// Find the Member and its associated SubChurch
	member := model.Member{}
	if err := r.DB.Where("id = ?", memberID).Preload("SubChurch").Find(&member).Error; err != nil {
		return nil, err
	}

	if member.SubChurch == nil {
		return nil, fmt.Errorf("Member is not associated with a SubChurch")
	}

	// Find the Church and its associated SubChurches
	church := model.Church{}
	if err := r.DB.Where("id = ?", member.SubChurch.ChurchID).Preload("SubChurches").Order("created_at DESC").Find(&church).Error; err != nil {
		return nil, err
	}

	// Return the list of SubChurches associated with the Church
	return church.SubChurches, nil
}

// GetAllMembersBySubChurchID is the resolver for the GetAllMembersBySubChurchID field.
func (r *queryResolver) GetAllMembersBySubChurchID(ctx context.Context, subChurchID string) ([]*model.Member, error) {
	var members []*model.Member
	if err := r.DB.Where("sub_church_id = ?", subChurchID).Preload("SubChurch").Order("created_at DESC").Find(&members).Error; err != nil {
		log.Printf("Error executing SQL query: %v", err)
		return nil, fmt.Errorf(" Error executing SQL query: %w", err)
	}

	// Convert pq.StringArray to []string
	for _, member := range members {
		member.Types = []string(member.Types)
	}
	return members, nil
}

// GetAllSubChurchLeader is the resolver for the GetAllSubChurchLeader field.
func (r *queryResolver) GetAllSubChurchLeader(ctx context.Context, subChurchID string) (*model.Member, error) {
	var leader model.Member

	if err := r.DB.Where("sub_church_id = ? AND types && ?", subChurchID, pq.Array([]string{"Leader"})).Order("created_at DESC").Find(&leader).Error; err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}
	return &leader, nil
}

// GetAllMembersByLeader is the resolver for the GetAllMembersByLeader field.
func (r *queryResolver) GetAllMembersByLeader(ctx context.Context, leaderID string) ([]*model.Member, error) {
	var members []*model.Member

	if err := r.DB.Where("leader_id = ?", leaderID).Preload("SubChurch").Order("created_at DESC").Find(&members).Error; err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}

	return members, nil
}

// GetAllSubLeaderByLeader is the resolver for the GetAllSubLeaderByLeader field.
func (r *queryResolver) GetAllSubLeaderByLeader(ctx context.Context, leaderID string) ([]*model.Member, error) {
	var members []*model.Member

	// Use GORM to query the database.
	if err := r.DB.Where("leader_id = ? AND types && ?", leaderID, pq.Array([]string{"SubLeader"})).Preload("SubChurch").Order("created_at DESC").Find(&members).Error; err != nil {
		// Handle the error, such as logging or returning an error response.
		return nil, err
	}

	return members, nil
}

// GetAllRegistersByMemberID is the resolver for the GetAllRegistersByMemberID field.
func (r *queryResolver) GetAllRegistersByMemberID(ctx context.Context, memberID string) ([]*model.Registration, error) {
	var Registrations []*model.Registration
	if err := r.DB.Where("member_id = ?", memberID).Preload("Member").Order("created_at DESC").Find(&Registrations).Error; err != nil {
		return nil, err
	}
	// Fetch LeaderNames based on LeaderIDs or set to "No Assign Caller" if LeaderID is nil
	for _, reg := range Registrations {
		if reg.LeaderID != nil {
			leaderMember := &model.Member{} // Assuming Leader is also a Member
			if err := r.DB.Where("id = ?", *reg.LeaderID).First(leaderMember).Error; err == nil {
				reg.LeaderName = &leaderMember.Name // Assuming you have a Name field in the Member model
			}
		} else {
			// Set LeaderName to "No Assign Caller" in the database when LeaderID is nil
			if err := r.DB.Model(&reg).Update(" LeaderName", "No Assign Caller").Error; err != nil {
				// Handle the error if needed
			}
		}
	}

	return Registrations, nil
}

// LastFourCommentsForMember is the resolver for the LastFourCommentsForMember field.
func (r *queryResolver) LastFourCommentsForMember(ctx context.Context, memberID string) ([]*string, error) {
	// Query the database for the last 4 registrations
	var Registrations []*model.Registration
	if err := r.DB.
		Where("member_id = ?", memberID).
		Order("created_at DESC").
		Limit(4). // Limit the result to the last 4 entries
		Find(&Registrations).
		Error; err != nil {
		return nil, err
	}

	// Extract the last 4 `lastComment` values as pointers to strings
	var comments []*string
	for _, reg := range Registrations {
		comment := reg.LastComment
		comments = append(comments, &comment)
	}

	return comments, nil
}

// GetAllsubChurch is the resolver for the GetAllsubChurch field.
func (r *queryResolver) GetAllsubChurch(ctx context.Context) ([]*model.SubChurch, error) {
	var sub []*model.SubChurch
	if err := r.DB.Preload("Members").Order("created_at DESC").Find(&sub).Error; err != nil {
		fmt.Println(" Error preloading associations:", err)
		return nil, err
	}

	return sub, nil
}

// GetCaller is the resolver for the GetCaller field.
func (r *queryResolver) GetCaller(ctx context.Context) ([]*model.Member, error) {
	var leaders []*model.Member
	// pq.Array([]string{"Leader", "SubLeader"})
	// Query the database to retrieve leaders with Types equal to "Caller" or "Admin"
	// if err := r.DB.Where("types IN (?)", []string{"CallAgent"}).Find(&leaders).Error; err != nil
	// if err := r.DB.Where("?'CallAgent'", "types").Find(&leaders).Error; err != nil
	if err := r.DB.Where("? = ANY(types)", "CallAgent").Order("created_at DESC").Find(&leaders).Error; err != nil {

		return nil, fmt.Errorf("failed to fetch leaders: %w", err)
	}

	return leaders, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	var post model.Post

	// Use GORM to find the post by its ID
	if err := r.DB.Where("id = ?", id).First(&post).Error; err != nil {
		return nil, err
	}

	return &post, nil
}

// Getmember is the resolver for the Getmember field.
func (r *queryResolver) Getmember(ctx context.Context, id string) (*model.Member, error) {
	var Member model.Member

	// Use GORM to find the Member by its ID
	if err := r.DB.Where("id = ?", id).Preload("SubChurch").First(&Member).Error; err != nil {
		return nil, err
	}

	return &Member, nil
}

// GetMigration is the resolver for the GetMigration field.
func (r *queryResolver) GetMigration(ctx context.Context, id string) (*model.MigrationRequest, error) {
	var migrate model.MigrationRequest

	// Use GORM to find the migrate by its ID
	if err := r.DB.Where("id = ?", id).First(&migrate).Error; err != nil {
		return nil, err
	}

	return &migrate, nil
}

// GetMigrationdestinationID is the resolver for the GetMigrationdestinationID field.
func (r *queryResolver) GetMigrationdestinationID(ctx context.Context, destinationChurchID string) ([]*model.MigrationRequest, error) {
	var migrationRequests []*model.MigrationRequest

	// Use GORM to query the database for migration requests with the given destinationChurchID and order them by CreatedAt in descending order
	if err := r.DB.Where("destination_church_id = ?", destinationChurchID).Order("created_at DESC").Find(&migrationRequests).Error; err != nil {
		return nil, err
	}

	return migrationRequests, nil
}

// GetMyType is the resolver for the GetMyType field.
func (r *queryResolver) GetMyType(ctx context.Context, id *string) (*model.MyType, error) {
	// Fetch the MyType object from the database by its ID
	var myType model.MyType
	if err := r.DB.Where("id = ?", id).First(&myType).Error; err != nil {
		return nil, err
	}

	return &myType, nil
}

// Getmembers is the resolver for the Getmembers field.
func (r *queryResolver) Getmembers(ctx context.Context) ([]*model.Member, error) {
	var leaders []*model.Member

	// Query the database to retrieve leaders with Types equal to "Caller" or "Admin"
	if err := r.DB.Find(&leaders).Order("created_at DESC").Error; err != nil {
		return nil, fmt.Errorf("failed to fetch leaders: %w", err)
	}

	return leaders, nil
}

// TodaysMembers is the resolver for the todaysMembers field.
func (r *queryResolver) TodaysMembers(ctx context.Context) ([]*model.Member, error) {
	// Implement logic to retrieve both today's and yesterday's members.

	today := time.Now()
	yesterday := today.AddDate(0, 0, -1)

	var members []*model.Member

	// Assuming you have a database or data source, you can query members created on both today and yesterday.
	if err := r.DB.Where("created_at >= ? AND created_at < ?", yesterday, today.AddDate(0, 0, 1)).Order("created_at DESC").Find(&members).Error; err != nil {
		return nil, err
	}

	return members, nil
}

// MembersByChurch is the resolver for the membersByChurch field.
func (r *queryResolver) MembersByChurch(ctx context.Context, churchID string) ([]*model.Member, error) {
	panic(fmt.Errorf("not implemented: MembersByChurch - membersByChurch"))
}

// GetsubChurchByID is the resolver for the GetsubChurchByID field.
func (r *queryResolver) GetsubChurchByID(ctx context.Context, id string) (*model.SubChurch, error) {
	var sub model.SubChurch

	// Use GORM to find the sub by its ID
	if err := r.DB.Where("id = ?", id).First(&sub).Error; err != nil {
		return nil, err
	}

	return &sub, nil
}

// GetChurchByMemberID is the resolver for the GetChurchByMemberID field.
func (r *queryResolver) GetChurchByMemberID(ctx context.Context, id string) (*model.Church, error) {
	panic(fmt.Errorf("not implemented: GetChurchByMemberID - GetChurchByMemberID"))
}

// GetAllChurchByID is the resolver for the GetAllChurchByID field.
func (r *queryResolver) GetAllChurchByID(ctx context.Context) ([]*model.Church, error) {
	// .Order("created_at DESC")
	panic(fmt.Errorf("not implemented: GetAllChurchByID - GetAllChurchByID"))
}

// MembersBySubChurchID is the resolver for the MembersBySubChurchID field.
func (r *queryResolver) MembersBySubChurchID(ctx context.Context, subChurchID string) ([]*model.Member, error) {
	var members []*model.Member
	if err := r.DB.
		Where("sub_church_id = ?", subChurchID).Preload("Registrations").Preload("Church").Order("created_at DESC").Find(&members).Error; err != nil {
		fmt.Println("Error preloading associations:", err)
		return nil, err
	}

	return members, nil
}

// RegistrationsByLeader is the resolver for the registrationsByLeader field.
func (r *queryResolver) RegistrationsByLeader(ctx context.Context, mleaderID string) ([]*model.Registration, error) {
	var registrations []*model.Registration

	// Preload the Leader and member associations
	if err := r.DB.Where("leader_id = ?", mleaderID).Preload("Leader").Preload("Member.SubChurch").Order("created_at DESC").Find(&registrations).Error; err != nil {
		fmt.Println("Error preloading associations:", err)
		return nil, err
	}

	return registrations, nil
}

// CallRoom is the resolver for the CallRoom field.
func (r *queryResolver) CallRoom(ctx context.Context, subChurchID string) ([]*model.Registration, error) {
	var registrations []*model.Registration

	// Preload the Leader and member associations
	// Preload the Leader and member associations
	if err := r.DB.Where("sub_church_id = ?", subChurchID).Preload("Leader").Preload("Member.SubChurch").Order("created_at DESC").Find(&registrations).Error; err != nil {
		fmt.Println("Error preloading associations:", err)
		return nil, err
	}

	return registrations, nil
}

// GetsubChurch is the resolver for the GetsubChurch field.
func (r *queryResolver) GetsubChurch(ctx context.Context, id string) (*model.SubChurch, error) {
	panic(fmt.Errorf("not implemented: GetsubChurch - GetsubChurch"))
}

// CurrentWeekRegistrations is the resolver for the currentWeekRegistrations field.
func (r *queryResolver) CurrentWeekRegistrations(ctx context.Context) ([]*model.Registration, error) {
	var registrations []*model.Registration
	if err := r.DB.Preload("Member").Order("created_at DESC").Find(&registrations).Error; err != nil {
		return nil, err
	}

	currentWeekNumber := schemas.GetWeekNumber(time.Now()) // Get the current week number

	// Fetch LeaderNames based on LeaderIDs or set to "No Assign Caller" if LeaderID is nil
	for _, reg := range registrations {
		MStext := "No Assign Caller"
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			if reg.LeaderID != nil {
				leaderMember := &model.Member{} // Assuming Leader is also a Member
				if err := r.DB.Where("id = ?", *reg.LeaderID).First(leaderMember).Error; err == nil {
					reg.LeaderName = &leaderMember.Name // Assuming you have a Name field in the Member model
				}
			} else {
				// Set LeaderName to "No Assign Caller" when LeaderID is nil
				reg.LeaderName = &MStext
			}
		}
	}

	var currentWeekRegistrations []*model.Registration
	for _, reg := range registrations {
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			currentWeekRegistrations = append(currentWeekRegistrations, reg)
		}
	}

	return currentWeekRegistrations, nil
}

// CurrentWeekRegistrationsforsub is the resolver for the currentWeekRegistrationsforsub field.
func (r *queryResolver) CurrentWeekRegistrationsforsub(ctx context.Context, subChurchID string) ([]*model.Registration, error) {
	var registrations []*model.Registration

	if err := r.DB.Preload("Member").Where("sub_church_id = ?", subChurchID).Order("created_at DESC").Find(&registrations).Error; err != nil {
		return nil, err
	}
	currentWeekNumber := schemas.GetWeekNumber(time.Now()) // Get the current week number

	// Fetch LeaderNames based on LeaderIDs or set to "No Assign Caller" if LeaderID is nil
	for _, reg := range registrations {
		MStext := "Not Called"
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			if reg.LeaderID != nil {
				leaderMember := &model.Member{} // Assuming Leader is also a Member
				if err := r.DB.Where("id = ?", *reg.LeaderID).First(leaderMember).Error; err == nil {
					reg.LeaderName = &leaderMember.Name // Assuming you have a Name field in the Member model
				}
			} else {
				// Set LeaderName to "No Assign Caller" when LeaderID is nil
				reg.LeaderName = &MStext
			}
		}
	}

	var currentWeekRegistrations []*model.Registration
	for _, reg := range registrations {
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			currentWeekRegistrations = append(currentWeekRegistrations, reg)
		}
	}

	return currentWeekRegistrations, nil
}

// WeekRegistrationsforSub is the resolver for the WeekRegistrationsforSub field.
func (r *queryResolver) WeekRegistrationsforSub(ctx context.Context) ([]*model.Registration, error) {
	// leaderID, ok := ctx.Value(middleware.IDContextKey).(string)
	// if !ok {
	// 	return nil, fmt.Errorf("leaderID not found in request context")
	// }
	var registrations []*model.Registration
	if err := r.DB.Preload("Member").Order("created_at DESC").Find(&registrations).Error; err != nil {
		return nil, err
	}
	currentWeekNumber := schemas.GetWeekNumber(time.Now()) // Get the current week number

	// Fetch LeaderNames based on LeaderIDs or set to "No Assign Caller" if LeaderID is nil
	for _, reg := range registrations {
		MStext := "No Assign Caller"
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			if reg.LeaderID != nil {
				leaderMember := &model.Member{} // Assuming Leader is also a Member
				if err := r.DB.Where("id = ?", *reg.LeaderID).First(leaderMember).Error; err == nil {
					reg.LeaderName = &leaderMember.Name // Assuming you have a Name field in the Member model
				}
			} else {
				// Set LeaderName to "No Assign Caller" when LeaderID is nil
				reg.LeaderName = &MStext
			}
		}
	}

	var currentWeekRegistrations []*model.Registration
	for _, reg := range registrations {
		if schemas.GetWeekNumber(reg.CreatedAt) == currentWeekNumber {
			currentWeekRegistrations = append(currentWeekRegistrations, reg)
		}
	}

	return currentWeekRegistrations, nil
}

// GetRegistrations is the resolver for the GetRegistrations field.
func (r *queryResolver) GetRegistrations(ctx context.Context) ([]*model.WeeklyResults, error) {
	panic(fmt.Errorf("not implemented: GetRegistrations - GetRegistrations"))
}

// ID is the resolver for the id field.
func (r *registrationResolver) ID(ctx context.Context, obj *model.Registration) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// ID is the resolver for the id field.
func (r *subChurchResolver) ID(ctx context.Context, obj *model.SubChurch) (string, error) {
	id := obj.ID.String()
	return id, nil
}

// Church returns ChurchResolver implementation.
func (r *Resolver) Church() ChurchResolver { return &churchResolver{r} }

// Member returns MemberResolver implementation.
func (r *Resolver) Member() MemberResolver { return &memberResolver{r} }

// MigrationRequest returns MigrationRequestResolver implementation.
func (r *Resolver) MigrationRequest() MigrationRequestResolver { return &migrationRequestResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// MyArr returns MyArrResolver implementation.
func (r *Resolver) MyArr() MyArrResolver { return &myArrResolver{r} }

// MyType returns MyTypeResolver implementation.
func (r *Resolver) MyType() MyTypeResolver { return &myTypeResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Registration returns RegistrationResolver implementation.
func (r *Resolver) Registration() RegistrationResolver { return &registrationResolver{r} }

// SubChurch returns SubChurchResolver implementation.
func (r *Resolver) SubChurch() SubChurchResolver { return &subChurchResolver{r} }

type churchResolver struct{ *Resolver }
type memberResolver struct{ *Resolver }
type migrationRequestResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type myArrResolver struct{ *Resolver }
type myTypeResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type registrationResolver struct{ *Resolver }
type subChurchResolver struct{ *Resolver }
